{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/SVGLoader.js","sources":["file:///Volumes/Space/asian-wires-cables/node_modules/src/loaders/SVGLoader.js"],"sourcesContent":["import {\n  Box2,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  Matrix3,\n  Path,\n  Shape,\n  ShapePath,\n  ShapeUtils,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst COLOR_SPACE_SVG = 'srgb'\n\nconst SVGLoader = /* @__PURE__ */ (() => {\n  class SVGLoader extends Loader {\n    constructor(manager) {\n      super(manager)\n\n      // Default dots per inch\n      this.defaultDPI = 90\n\n      // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n      this.defaultUnit = 'px'\n    }\n\n    load(url, onLoad, onProgress, onError) {\n      const scope = this\n\n      const loader = new FileLoader(scope.manager)\n      loader.setPath(scope.path)\n      loader.setRequestHeader(scope.requestHeader)\n      loader.setWithCredentials(scope.withCredentials)\n      loader.load(\n        url,\n        function (text) {\n          try {\n            onLoad(scope.parse(text))\n          } catch (e) {\n            if (onError) {\n              onError(e)\n            } else {\n              console.error(e)\n            }\n\n            scope.manager.itemError(url)\n          }\n        },\n        onProgress,\n        onError,\n      )\n    }\n\n    parse(text) {\n      const scope = this\n\n      function parseNode(node, style) {\n        if (node.nodeType !== 1) return\n\n        const transform = getNodeTransform(node)\n\n        let isDefsNode = false\n\n        let path = null\n\n        switch (node.nodeName) {\n          case 'svg':\n            style = parseStyle(node, style)\n            break\n\n          case 'style':\n            parseCSSStylesheet(node)\n            break\n\n          case 'g':\n            style = parseStyle(node, style)\n            break\n\n          case 'path':\n            style = parseStyle(node, style)\n            if (node.hasAttribute('d')) path = parsePathNode(node)\n            break\n\n          case 'rect':\n            style = parseStyle(node, style)\n            path = parseRectNode(node)\n            break\n\n          case 'polygon':\n            style = parseStyle(node, style)\n            path = parsePolygonNode(node)\n            break\n\n          case 'polyline':\n            style = parseStyle(node, style)\n            path = parsePolylineNode(node)\n            break\n\n          case 'circle':\n            style = parseStyle(node, style)\n            path = parseCircleNode(node)\n            break\n\n          case 'ellipse':\n            style = parseStyle(node, style)\n            path = parseEllipseNode(node)\n            break\n\n          case 'line':\n            style = parseStyle(node, style)\n            path = parseLineNode(node)\n            break\n\n          case 'defs':\n            isDefsNode = true\n            break\n\n          case 'use':\n            style = parseStyle(node, style)\n\n            const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || ''\n            const usedNodeId = href.substring(1)\n            const usedNode = node.viewportElement.getElementById(usedNodeId)\n            if (usedNode) {\n              parseNode(usedNode, style)\n            } else {\n              console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId)\n            }\n\n            break\n\n          default:\n          // console.log( node );\n        }\n\n        if (path) {\n          if (style.fill !== undefined && style.fill !== 'none') {\n            path.color.setStyle(style.fill, COLOR_SPACE_SVG)\n          }\n\n          transformPath(path, currentTransform)\n\n          paths.push(path)\n\n          path.userData = { node: node, style: style }\n        }\n\n        const childNodes = node.childNodes\n\n        for (let i = 0; i < childNodes.length; i++) {\n          const node = childNodes[i]\n\n          if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n            // Ignore everything in defs except CSS style definitions\n            // and nested defs, because it is OK by the standard to have\n            // <style/> there.\n            continue\n          }\n\n          parseNode(node, style)\n        }\n\n        if (transform) {\n          transformStack.pop()\n\n          if (transformStack.length > 0) {\n            currentTransform.copy(transformStack[transformStack.length - 1])\n          } else {\n            currentTransform.identity()\n          }\n        }\n      }\n\n      function parsePathNode(node) {\n        const path = new ShapePath()\n\n        const point = new Vector2()\n        const control = new Vector2()\n\n        const firstPoint = new Vector2()\n        let isFirstPoint = true\n        let doSetFirstPoint = false\n\n        const d = node.getAttribute('d')\n\n        if (d === '' || d === 'none') return null\n\n        // console.log( d );\n\n        const commands = d.match(/[a-df-z][^a-df-z]*/gi)\n\n        for (let i = 0, l = commands.length; i < l; i++) {\n          const command = commands[i]\n\n          const type = command.charAt(0)\n          const data = command.slice(1).trim()\n\n          if (isFirstPoint === true) {\n            doSetFirstPoint = true\n            isFirstPoint = false\n          }\n\n          let numbers\n\n          switch (type) {\n            case 'M':\n              numbers = parseFloats(data)\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y)\n                } else {\n                  path.lineTo(point.x, point.y)\n                }\n\n                if (j === 0) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'H':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x = numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'V':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y = numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'L':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'C':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  numbers[j + 5],\n                )\n                control.x = numbers[j + 2]\n                control.y = numbers[j + 3]\n                point.x = numbers[j + 4]\n                point.y = numbers[j + 5]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'S':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  numbers[j + 0],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                )\n                control.x = numbers[j + 0]\n                control.y = numbers[j + 1]\n                point.x = numbers[j + 2]\n                point.y = numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'Q':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\n                control.x = numbers[j + 0]\n                control.y = numbers[j + 1]\n                point.x = numbers[j + 2]\n                point.y = numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'T':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x)\n                const ry = getReflection(point.y, control.y)\n                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\n                control.x = rx\n                control.y = ry\n                point.x = numbers[j + 0]\n                point.y = numbers[j + 1]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'A':\n              numbers = parseFloats(data, [3, 4], 7)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                // skip command if start point == end point\n                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue\n\n                const start = point.clone()\n                point.x = numbers[j + 5]\n                point.y = numbers[j + 6]\n                control.x = point.x\n                control.y = point.y\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point,\n                )\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'm':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0]\n                point.y += numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n\n                if (j === 0) {\n                  path.moveTo(point.x, point.y)\n                } else {\n                  path.lineTo(point.x, point.y)\n                }\n\n                if (j === 0) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'h':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.x += numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'v':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j++) {\n                point.y += numbers[j]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'l':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                point.x += numbers[j + 0]\n                point.y += numbers[j + 1]\n                control.x = point.x\n                control.y = point.y\n                path.lineTo(point.x, point.y)\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'c':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n                path.bezierCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                  point.x + numbers[j + 4],\n                  point.y + numbers[j + 5],\n                )\n                control.x = point.x + numbers[j + 2]\n                control.y = point.y + numbers[j + 3]\n                point.x += numbers[j + 4]\n                point.y += numbers[j + 5]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 's':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.bezierCurveTo(\n                  getReflection(point.x, control.x),\n                  getReflection(point.y, control.y),\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                )\n                control.x = point.x + numbers[j + 0]\n                control.y = point.y + numbers[j + 1]\n                point.x += numbers[j + 2]\n                point.y += numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'q':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n                path.quadraticCurveTo(\n                  point.x + numbers[j + 0],\n                  point.y + numbers[j + 1],\n                  point.x + numbers[j + 2],\n                  point.y + numbers[j + 3],\n                )\n                control.x = point.x + numbers[j + 0]\n                control.y = point.y + numbers[j + 1]\n                point.x += numbers[j + 2]\n                point.y += numbers[j + 3]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 't':\n              numbers = parseFloats(data)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n                const rx = getReflection(point.x, control.x)\n                const ry = getReflection(point.y, control.y)\n                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\n                control.x = rx\n                control.y = ry\n                point.x = point.x + numbers[j + 0]\n                point.y = point.y + numbers[j + 1]\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'a':\n              numbers = parseFloats(data, [3, 4], 7)\n\n              for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n                // skip command if no displacement\n                if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue\n\n                const start = point.clone()\n                point.x += numbers[j + 5]\n                point.y += numbers[j + 6]\n                control.x = point.x\n                control.y = point.y\n                parseArcCommand(\n                  path,\n                  numbers[j],\n                  numbers[j + 1],\n                  numbers[j + 2],\n                  numbers[j + 3],\n                  numbers[j + 4],\n                  start,\n                  point,\n                )\n\n                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n              }\n\n              break\n\n            case 'Z':\n            case 'z':\n              path.currentPath.autoClose = true\n\n              if (path.currentPath.curves.length > 0) {\n                // Reset point to beginning of Path\n                point.copy(firstPoint)\n                path.currentPath.currentPoint.copy(point)\n                isFirstPoint = true\n              }\n\n              break\n\n            default:\n              console.warn(command)\n          }\n\n          // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n          doSetFirstPoint = false\n        }\n\n        return path\n      }\n\n      function parseCSSStylesheet(node) {\n        if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return\n\n        for (let i = 0; i < node.sheet.cssRules.length; i++) {\n          const stylesheet = node.sheet.cssRules[i]\n\n          if (stylesheet.type !== 1) continue\n\n          const selectorList = stylesheet.selectorText\n            .split(/,/gm)\n            .filter(Boolean)\n            .map((i) => i.trim())\n\n          for (let j = 0; j < selectorList.length; j++) {\n            // Remove empty rules\n            const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== ''))\n\n            stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions)\n          }\n        }\n      }\n\n      /**\n       * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n       * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n       * From\n       * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n       * To\n       * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n       */\n\n      function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n        if (rx == 0 || ry == 0) {\n          // draw a line if either of the radii == 0\n          path.lineTo(end.x, end.y)\n          return\n        }\n\n        x_axis_rotation = (x_axis_rotation * Math.PI) / 180\n\n        // Ensure radii are positive\n        rx = Math.abs(rx)\n        ry = Math.abs(ry)\n\n        // Compute (x1', y1')\n        const dx2 = (start.x - end.x) / 2.0\n        const dy2 = (start.y - end.y) / 2.0\n        const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\n        const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\n\n        // Compute (cx', cy')\n        let rxs = rx * rx\n        let rys = ry * ry\n        const x1ps = x1p * x1p\n        const y1ps = y1p * y1p\n\n        // Ensure radii are large enough\n        const cr = x1ps / rxs + y1ps / rys\n\n        if (cr > 1) {\n          // scale up rx,ry equally so cr == 1\n          const s = Math.sqrt(cr)\n          rx = s * rx\n          ry = s * ry\n          rxs = rx * rx\n          rys = ry * ry\n        }\n\n        const dq = rxs * y1ps + rys * x1ps\n        const pq = (rxs * rys - dq) / dq\n        let q = Math.sqrt(Math.max(0, pq))\n        if (large_arc_flag === sweep_flag) q = -q\n        const cxp = (q * rx * y1p) / ry\n        const cyp = (-q * ry * x1p) / rx\n\n        // Step 3: Compute (cx, cy) from (cx', cy')\n        const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\n        const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\n\n        // Step 4: Compute θ1 and Δθ\n        const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\n        const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\n\n        path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\n      }\n\n      function svgAngle(ux, uy, vx, vy) {\n        const dot = ux * vx + uy * vy\n        const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\n        let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\n        if (ux * vy - uy * vx < 0) ang = -ang\n        return ang\n      }\n\n      /*\n       * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n       * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n       */\n      function parseRectNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('x') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('y') || 0)\n        const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0)\n        const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0)\n        const w = parseFloatWithUnits(node.getAttribute('width'))\n        const h = parseFloatWithUnits(node.getAttribute('height'))\n\n        // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n        // https://spencermortensen.com/articles/bezier-circle/\n        const bci = 1 - 0.551915024494\n\n        const path = new ShapePath()\n\n        // top left\n        path.moveTo(x + rx, y)\n\n        // top right\n        path.lineTo(x + w - rx, y)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry)\n        }\n\n        // bottom right\n        path.lineTo(x + w, y + h - ry)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h)\n        }\n\n        // bottom left\n        path.lineTo(x + rx, y + h)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry)\n        }\n\n        // back to top left\n        path.lineTo(x, y + ry)\n        if (rx !== 0 || ry !== 0) {\n          path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y)\n        }\n\n        return path\n      }\n\n      function parsePolygonNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a)\n          const y = parseFloatWithUnits(b)\n\n          if (index === 0) {\n            path.moveTo(x, y)\n          } else {\n            path.lineTo(x, y)\n          }\n\n          index++\n        }\n\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n        const path = new ShapePath()\n\n        let index = 0\n\n        node.getAttribute('points').replace(regex, iterator)\n\n        path.currentPath.autoClose = true\n\n        return path\n      }\n\n      function parsePolylineNode(node) {\n        function iterator(match, a, b) {\n          const x = parseFloatWithUnits(a)\n          const y = parseFloatWithUnits(b)\n\n          if (index === 0) {\n            path.moveTo(x, y)\n          } else {\n            path.lineTo(x, y)\n          }\n\n          index++\n        }\n\n        const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n        const path = new ShapePath()\n\n        let index = 0\n\n        node.getAttribute('points').replace(regex, iterator)\n\n        path.currentPath.autoClose = false\n\n        return path\n      }\n\n      function parseCircleNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n        const r = parseFloatWithUnits(node.getAttribute('r') || 0)\n\n        const subpath = new Path()\n        subpath.absarc(x, y, r, 0, Math.PI * 2)\n\n        const path = new ShapePath()\n        path.subPaths.push(subpath)\n\n        return path\n      }\n\n      function parseEllipseNode(node) {\n        const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n        const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n        const rx = parseFloatWithUnits(node.getAttribute('rx') || 0)\n        const ry = parseFloatWithUnits(node.getAttribute('ry') || 0)\n\n        const subpath = new Path()\n        subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2)\n\n        const path = new ShapePath()\n        path.subPaths.push(subpath)\n\n        return path\n      }\n\n      function parseLineNode(node) {\n        const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0)\n        const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0)\n        const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0)\n        const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0)\n\n        const path = new ShapePath()\n        path.moveTo(x1, y1)\n        path.lineTo(x2, y2)\n        path.currentPath.autoClose = false\n\n        return path\n      }\n\n      //\n\n      function parseStyle(node, style) {\n        style = Object.assign({}, style) // clone style\n\n        let stylesheetStyles = {}\n\n        if (node.hasAttribute('class')) {\n          const classSelectors = node\n            .getAttribute('class')\n            .split(/\\s/)\n            .filter(Boolean)\n            .map((i) => i.trim())\n\n          for (let i = 0; i < classSelectors.length; i++) {\n            stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]])\n          }\n        }\n\n        if (node.hasAttribute('id')) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')])\n        }\n\n        function addStyle(svgName, jsName, adjustFunction) {\n          if (adjustFunction === undefined)\n            adjustFunction = function copy(v) {\n              if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.')\n\n              return v\n            }\n\n          if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName))\n          if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName])\n          if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName])\n        }\n\n        function clamp(v) {\n          return Math.max(0, Math.min(1, parseFloatWithUnits(v)))\n        }\n\n        function positive(v) {\n          return Math.max(0, parseFloatWithUnits(v))\n        }\n\n        addStyle('fill', 'fill')\n        addStyle('fill-opacity', 'fillOpacity', clamp)\n        addStyle('fill-rule', 'fillRule')\n        addStyle('opacity', 'opacity', clamp)\n        addStyle('stroke', 'stroke')\n        addStyle('stroke-opacity', 'strokeOpacity', clamp)\n        addStyle('stroke-width', 'strokeWidth', positive)\n        addStyle('stroke-linejoin', 'strokeLineJoin')\n        addStyle('stroke-linecap', 'strokeLineCap')\n        addStyle('stroke-miterlimit', 'strokeMiterLimit', positive)\n        addStyle('visibility', 'visibility')\n\n        return style\n      }\n\n      // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n      function getReflection(a, b) {\n        return a - (b - a)\n      }\n\n      // from https://github.com/ppvg/svg-numbers (MIT License)\n\n      function parseFloats(input, flags, stride) {\n        if (typeof input !== 'string') {\n          throw new TypeError('Invalid input: ' + typeof input)\n        }\n\n        // Character groups\n        const RE = {\n          SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n          WHITESPACE: /[ \\t\\r\\n]/,\n          DIGIT: /[\\d]/,\n          SIGN: /[-+]/,\n          POINT: /\\./,\n          COMMA: /,/,\n          EXP: /e/i,\n          FLAGS: /[01]/,\n        }\n\n        // States\n        const SEP = 0\n        const INT = 1\n        const FLOAT = 2\n        const EXP = 3\n\n        let state = SEP\n        let seenComma = true\n        let number = '',\n          exponent = ''\n        const result = []\n\n        function throwSyntaxError(current, i, partial) {\n          const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.')\n          error.partial = partial\n          throw error\n        }\n\n        function newNumber() {\n          if (number !== '') {\n            if (exponent === '') result.push(Number(number))\n            else result.push(Number(number) * Math.pow(10, Number(exponent)))\n          }\n\n          number = ''\n          exponent = ''\n        }\n\n        let current\n        const length = input.length\n\n        for (let i = 0; i < length; i++) {\n          current = input[i]\n\n          // check for flags\n          if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n            state = INT\n            number = current\n            newNumber()\n            continue\n          }\n\n          // parse until next number\n          if (state === SEP) {\n            // eat whitespace\n            if (RE.WHITESPACE.test(current)) {\n              continue\n            }\n\n            // start new number\n            if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n              state = INT\n              number = current\n              continue\n            }\n\n            if (RE.POINT.test(current)) {\n              state = FLOAT\n              number = current\n              continue\n            }\n\n            // throw on double commas (e.g. \"1, , 2\")\n            if (RE.COMMA.test(current)) {\n              if (seenComma) {\n                throwSyntaxError(current, i, result)\n              }\n\n              seenComma = true\n            }\n          }\n\n          // parse integer part\n          if (state === INT) {\n            if (RE.DIGIT.test(current)) {\n              number += current\n              continue\n            }\n\n            if (RE.POINT.test(current)) {\n              number += current\n              state = FLOAT\n              continue\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP\n              continue\n            }\n\n            // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n            if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n              throwSyntaxError(current, i, result)\n            }\n          }\n\n          // parse decimal part\n          if (state === FLOAT) {\n            if (RE.DIGIT.test(current)) {\n              number += current\n              continue\n            }\n\n            if (RE.EXP.test(current)) {\n              state = EXP\n              continue\n            }\n\n            // throw on double decimal points (e.g. \"1..2\")\n            if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n              throwSyntaxError(current, i, result)\n            }\n          }\n\n          // parse exponent part\n          if (state === EXP) {\n            if (RE.DIGIT.test(current)) {\n              exponent += current\n              continue\n            }\n\n            if (RE.SIGN.test(current)) {\n              if (exponent === '') {\n                exponent += current\n                continue\n              }\n\n              if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n                throwSyntaxError(current, i, result)\n              }\n            }\n          }\n\n          // end of number\n          if (RE.WHITESPACE.test(current)) {\n            newNumber()\n            state = SEP\n            seenComma = false\n          } else if (RE.COMMA.test(current)) {\n            newNumber()\n            state = SEP\n            seenComma = true\n          } else if (RE.SIGN.test(current)) {\n            newNumber()\n            state = INT\n            number = current\n          } else if (RE.POINT.test(current)) {\n            newNumber()\n            state = FLOAT\n            number = current\n          } else {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // add the last number found (if any)\n        newNumber()\n\n        return result\n      }\n\n      // Units\n\n      const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']\n\n      // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n      const unitConversion = {\n        mm: {\n          mm: 1,\n          cm: 0.1,\n          in: 1 / 25.4,\n          pt: 72 / 25.4,\n          pc: 6 / 25.4,\n          px: -1,\n        },\n        cm: {\n          mm: 10,\n          cm: 1,\n          in: 1 / 2.54,\n          pt: 72 / 2.54,\n          pc: 6 / 2.54,\n          px: -1,\n        },\n        in: {\n          mm: 25.4,\n          cm: 2.54,\n          in: 1,\n          pt: 72,\n          pc: 6,\n          px: -1,\n        },\n        pt: {\n          mm: 25.4 / 72,\n          cm: 2.54 / 72,\n          in: 1 / 72,\n          pt: 1,\n          pc: 6 / 72,\n          px: -1,\n        },\n        pc: {\n          mm: 25.4 / 6,\n          cm: 2.54 / 6,\n          in: 1 / 6,\n          pt: 72 / 6,\n          pc: 1,\n          px: -1,\n        },\n        px: {\n          px: 1,\n        },\n      }\n\n      function parseFloatWithUnits(string) {\n        let theUnit = 'px'\n\n        if (typeof string === 'string' || string instanceof String) {\n          for (let i = 0, n = units.length; i < n; i++) {\n            const u = units[i]\n\n            if (string.endsWith(u)) {\n              theUnit = u\n              string = string.substring(0, string.length - u.length)\n              break\n            }\n          }\n        }\n\n        let scale = undefined\n\n        if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n          // Conversion scale from  pixels to inches, then to default units\n\n          scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI\n        } else {\n          scale = unitConversion[theUnit][scope.defaultUnit]\n\n          if (scale < 0) {\n            // Conversion scale to pixels\n\n            scale = unitConversion[theUnit]['in'] * scope.defaultDPI\n          }\n        }\n\n        return scale * parseFloat(string)\n      }\n\n      // Transforms\n\n      function getNodeTransform(node) {\n        if (\n          !(\n            node.hasAttribute('transform') ||\n            (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))\n          )\n        ) {\n          return null\n        }\n\n        const transform = parseNodeTransform(node)\n\n        if (transformStack.length > 0) {\n          transform.premultiply(transformStack[transformStack.length - 1])\n        }\n\n        currentTransform.copy(transform)\n        transformStack.push(transform)\n\n        return transform\n      }\n\n      function parseNodeTransform(node) {\n        const transform = new Matrix3()\n        const currentTransform = tempTransform0\n\n        if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n          const tx = parseFloatWithUnits(node.getAttribute('x'))\n          const ty = parseFloatWithUnits(node.getAttribute('y'))\n\n          transform.translate(tx, ty)\n        }\n\n        if (node.hasAttribute('transform')) {\n          const transformsTexts = node.getAttribute('transform').split(')')\n\n          for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n            const transformText = transformsTexts[tIndex].trim()\n\n            if (transformText === '') continue\n\n            const openParPos = transformText.indexOf('(')\n            const closeParPos = transformText.length\n\n            if (openParPos > 0 && openParPos < closeParPos) {\n              const transformType = transformText.slice(0, openParPos)\n\n              const array = parseFloats(transformText.slice(openParPos + 1))\n\n              currentTransform.identity()\n\n              switch (transformType) {\n                case 'translate':\n                  if (array.length >= 1) {\n                    const tx = array[0]\n                    let ty = 0\n\n                    if (array.length >= 2) {\n                      ty = array[1]\n                    }\n\n                    currentTransform.translate(tx, ty)\n                  }\n\n                  break\n\n                case 'rotate':\n                  if (array.length >= 1) {\n                    let angle = 0\n                    let cx = 0\n                    let cy = 0\n\n                    // Angle\n                    angle = (array[0] * Math.PI) / 180\n\n                    if (array.length >= 3) {\n                      // Center x, y\n                      cx = array[1]\n                      cy = array[2]\n                    }\n\n                    // Rotate around center (cx, cy)\n                    tempTransform1.makeTranslation(-cx, -cy)\n                    tempTransform2.makeRotation(angle)\n                    tempTransform3.multiplyMatrices(tempTransform2, tempTransform1)\n                    tempTransform1.makeTranslation(cx, cy)\n                    currentTransform.multiplyMatrices(tempTransform1, tempTransform3)\n                  }\n\n                  break\n\n                case 'scale':\n                  if (array.length >= 1) {\n                    const scaleX = array[0]\n                    let scaleY = scaleX\n\n                    if (array.length >= 2) {\n                      scaleY = array[1]\n                    }\n\n                    currentTransform.scale(scaleX, scaleY)\n                  }\n\n                  break\n\n                case 'skewX':\n                  if (array.length === 1) {\n                    currentTransform.set(1, Math.tan((array[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)\n                  }\n\n                  break\n\n                case 'skewY':\n                  if (array.length === 1) {\n                    currentTransform.set(1, 0, 0, Math.tan((array[0] * Math.PI) / 180), 1, 0, 0, 0, 1)\n                  }\n\n                  break\n\n                case 'matrix':\n                  if (array.length === 6) {\n                    currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1)\n                  }\n\n                  break\n              }\n            }\n\n            transform.premultiply(currentTransform)\n          }\n        }\n\n        return transform\n      }\n\n      function transformPath(path, m) {\n        function transfVec2(v2) {\n          tempV3.set(v2.x, v2.y, 1).applyMatrix3(m)\n\n          v2.set(tempV3.x, tempV3.y)\n        }\n\n        function transfEllipseGeneric(curve) {\n          // For math description see:\n          // https://math.stackexchange.com/questions/4544164\n\n          const a = curve.xRadius\n          const b = curve.yRadius\n\n          const cosTheta = Math.cos(curve.aRotation)\n          const sinTheta = Math.sin(curve.aRotation)\n\n          const v1 = new Vector3(a * cosTheta, a * sinTheta, 0)\n          const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0)\n\n          const f1 = v1.applyMatrix3(m)\n          const f2 = v2.applyMatrix3(m)\n\n          const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1)\n\n          const mFInv = tempTransform1.copy(mF).invert()\n          const mFInvT = tempTransform2.copy(mFInv).transpose()\n          const mQ = mFInvT.multiply(mFInv)\n          const mQe = mQ.elements\n\n          const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4])\n          const rt1sqrt = Math.sqrt(ed.rt1)\n          const rt2sqrt = Math.sqrt(ed.rt2)\n\n          curve.xRadius = 1 / rt1sqrt\n          curve.yRadius = 1 / rt2sqrt\n          curve.aRotation = Math.atan2(ed.sn, ed.cs)\n\n          const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON\n\n          // Do not touch angles of a full ellipse because after transformation they\n          // would converge to a sinle value effectively removing the whole curve\n\n          if (!isFullEllipse) {\n            const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1)\n\n            const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1)\n\n            const mDRF = mDsqrt.multiply(mRT).multiply(mF)\n\n            const transformAngle = (phi) => {\n              const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF)\n\n              return Math.atan2(sinR, cosR)\n            }\n\n            curve.aStartAngle = transformAngle(curve.aStartAngle)\n            curve.aEndAngle = transformAngle(curve.aEndAngle)\n\n            if (isTransformFlipped(m)) {\n              curve.aClockwise = !curve.aClockwise\n            }\n          }\n        }\n\n        function transfEllipseNoSkew(curve) {\n          // Faster shortcut if no skew is applied\n          // (e.g, a euclidean transform of a group containing the ellipse)\n\n          const sx = getTransformScaleX(m)\n          const sy = getTransformScaleY(m)\n\n          curve.xRadius *= sx\n          curve.yRadius *= sy\n\n          // Extract rotation angle from the matrix of form:\n          //\n          //  | cosθ sx   -sinθ sy |\n          //  | sinθ sx    cosθ sy |\n          //\n          // Remembering that tanθ = sinθ / cosθ; and that\n          // `sx`, `sy`, or both might be zero.\n          const theta =\n            sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4])\n\n          curve.aRotation += theta\n\n          if (isTransformFlipped(m)) {\n            curve.aStartAngle *= -1\n            curve.aEndAngle *= -1\n            curve.aClockwise = !curve.aClockwise\n          }\n        }\n\n        const subPaths = path.subPaths\n\n        for (let i = 0, n = subPaths.length; i < n; i++) {\n          const subPath = subPaths[i]\n          const curves = subPath.curves\n\n          for (let j = 0; j < curves.length; j++) {\n            const curve = curves[j]\n\n            if (curve.isLineCurve) {\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n            } else if (curve.isCubicBezierCurve) {\n              transfVec2(curve.v0)\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n              transfVec2(curve.v3)\n            } else if (curve.isQuadraticBezierCurve) {\n              transfVec2(curve.v0)\n              transfVec2(curve.v1)\n              transfVec2(curve.v2)\n            } else if (curve.isEllipseCurve) {\n              // Transform ellipse center point\n\n              tempV2.set(curve.aX, curve.aY)\n              transfVec2(tempV2)\n              curve.aX = tempV2.x\n              curve.aY = tempV2.y\n\n              // Transform ellipse shape parameters\n\n              if (isTransformSkewed(m)) {\n                transfEllipseGeneric(curve)\n              } else {\n                transfEllipseNoSkew(curve)\n              }\n            }\n          }\n        }\n      }\n\n      function isTransformFlipped(m) {\n        const te = m.elements\n        return te[0] * te[4] - te[1] * te[3] < 0\n      }\n\n      function isTransformSkewed(m) {\n        const te = m.elements\n        const basisDot = te[0] * te[3] + te[1] * te[4]\n\n        // Shortcut for trivial rotations and transformations\n        if (basisDot === 0) return false\n\n        const sx = getTransformScaleX(m)\n        const sy = getTransformScaleY(m)\n\n        return Math.abs(basisDot / (sx * sy)) > Number.EPSILON\n      }\n\n      function getTransformScaleX(m) {\n        const te = m.elements\n        return Math.sqrt(te[0] * te[0] + te[1] * te[1])\n      }\n\n      function getTransformScaleY(m) {\n        const te = m.elements\n        return Math.sqrt(te[3] * te[3] + te[4] * te[4])\n      }\n\n      // Calculates the eigensystem of a real symmetric 2x2 matrix\n      //    [ A  B ]\n      //    [ B  C ]\n      // in the form\n      //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n      //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n      // where rt1 >= rt2.\n      //\n      // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n      // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n      function eigenDecomposition(A, B, C) {\n        let rt1, rt2, cs, sn, t\n        const sm = A + C\n        const df = A - C\n        const rt = Math.sqrt(df * df + 4 * B * B)\n\n        if (sm > 0) {\n          rt1 = 0.5 * (sm + rt)\n          t = 1 / rt1\n          rt2 = A * t * C - B * t * B\n        } else if (sm < 0) {\n          rt2 = 0.5 * (sm - rt)\n        } else {\n          // This case needs to be treated separately to avoid div by 0\n\n          rt1 = 0.5 * rt\n          rt2 = -0.5 * rt\n        }\n\n        // Calculate eigenvectors\n\n        if (df > 0) {\n          cs = df + rt\n        } else {\n          cs = df - rt\n        }\n\n        if (Math.abs(cs) > 2 * Math.abs(B)) {\n          t = (-2 * B) / cs\n          sn = 1 / Math.sqrt(1 + t * t)\n          cs = t * sn\n        } else if (Math.abs(B) === 0) {\n          cs = 1\n          sn = 0\n        } else {\n          t = (-0.5 * cs) / B\n          cs = 1 / Math.sqrt(1 + t * t)\n          sn = t * cs\n        }\n\n        if (df > 0) {\n          t = cs\n          cs = -sn\n          sn = t\n        }\n\n        return { rt1, rt2, cs, sn }\n      }\n\n      //\n\n      const paths = []\n      const stylesheets = {}\n\n      const transformStack = []\n\n      const tempTransform0 = new Matrix3()\n      const tempTransform1 = new Matrix3()\n      const tempTransform2 = new Matrix3()\n      const tempTransform3 = new Matrix3()\n      const tempV2 = new Vector2()\n      const tempV3 = new Vector3()\n\n      const currentTransform = new Matrix3()\n\n      const xml = new DOMParser().parseFromString(text, 'image/svg+xml') // application/xml\n\n      parseNode(xml.documentElement, {\n        fill: '#000',\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        strokeWidth: 1,\n        strokeLineJoin: 'miter',\n        strokeLineCap: 'butt',\n        strokeMiterLimit: 4,\n      })\n\n      const data = { paths: paths, xml: xml.documentElement }\n\n      // console.log( paths );\n      return data\n    }\n\n    static createShapes(shapePath) {\n      // Param shapePath: a shapepath as returned by the parse function of this class\n      // Returns Shape object\n\n      const BIGNUMBER = 999999999\n\n      const IntersectionLocationType = {\n        ORIGIN: 0,\n        DESTINATION: 1,\n        BETWEEN: 2,\n        LEFT: 3,\n        RIGHT: 4,\n        BEHIND: 5,\n        BEYOND: 6,\n      }\n\n      const classifyResult = {\n        loc: IntersectionLocationType.ORIGIN,\n        t: 0,\n      }\n\n      function findEdgeIntersection(a0, a1, b0, b1) {\n        const x1 = a0.x\n        const x2 = a1.x\n        const x3 = b0.x\n        const x4 = b1.x\n        const y1 = a0.y\n        const y2 = a1.y\n        const y3 = b0.y\n        const y4 = b1.y\n        const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n        const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\n        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n        const t1 = nom1 / denom\n        const t2 = nom2 / denom\n\n        if ((denom === 0 && nom1 !== 0) || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n          //1. lines are parallel or edges don't intersect\n\n          return null\n        } else if (nom1 === 0 && denom === 0) {\n          //2. lines are colinear\n\n          //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1)\n            //find position of this endpoints relatively to edge1\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1\n              return { x: point.x, y: point.y, t: classifyResult.t }\n            } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n              const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10)\n              const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10)\n              return { x: x, y: y, t: classifyResult.t }\n            }\n          }\n\n          return null\n        } else {\n          //3. edges intersect\n\n          for (let i = 0; i < 2; i++) {\n            classifyPoint(i === 0 ? b0 : b1, a0, a1)\n\n            if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n              const point = i === 0 ? b0 : b1\n              return { x: point.x, y: point.y, t: classifyResult.t }\n            }\n          }\n\n          const x = +(x1 + t1 * (x2 - x1)).toPrecision(10)\n          const y = +(y1 + t1 * (y2 - y1)).toPrecision(10)\n          return { x: x, y: y, t: t1 }\n        }\n      }\n\n      function classifyPoint(p, edgeStart, edgeEnd) {\n        const ax = edgeEnd.x - edgeStart.x\n        const ay = edgeEnd.y - edgeStart.y\n        const bx = p.x - edgeStart.x\n        const by = p.y - edgeStart.y\n        const sa = ax * by - bx * ay\n\n        if (p.x === edgeStart.x && p.y === edgeStart.y) {\n          classifyResult.loc = IntersectionLocationType.ORIGIN\n          classifyResult.t = 0\n          return\n        }\n\n        if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n          classifyResult.loc = IntersectionLocationType.DESTINATION\n          classifyResult.t = 1\n          return\n        }\n\n        if (sa < -Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.LEFT\n          return\n        }\n\n        if (sa > Number.EPSILON) {\n          classifyResult.loc = IntersectionLocationType.RIGHT\n          return\n        }\n\n        if (ax * bx < 0 || ay * by < 0) {\n          classifyResult.loc = IntersectionLocationType.BEHIND\n          return\n        }\n\n        if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n          classifyResult.loc = IntersectionLocationType.BEYOND\n          return\n        }\n\n        let t\n\n        if (ax !== 0) {\n          t = bx / ax\n        } else {\n          t = by / ay\n        }\n\n        classifyResult.loc = IntersectionLocationType.BETWEEN\n        classifyResult.t = t\n      }\n\n      function getIntersections(path1, path2) {\n        const intersectionsRaw = []\n        const intersections = []\n\n        for (let index = 1; index < path1.length; index++) {\n          const path1EdgeStart = path1[index - 1]\n          const path1EdgeEnd = path1[index]\n\n          for (let index2 = 1; index2 < path2.length; index2++) {\n            const path2EdgeStart = path2[index2 - 1]\n            const path2EdgeEnd = path2[index2]\n\n            const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd)\n\n            if (\n              intersection !== null &&\n              intersectionsRaw.find(\n                (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON,\n              ) === undefined\n            ) {\n              intersectionsRaw.push(intersection)\n              intersections.push(new Vector2(intersection.x, intersection.y))\n            }\n          }\n        }\n\n        return intersections\n      }\n\n      function getScanlineIntersections(scanline, boundingBox, paths) {\n        const center = new Vector2()\n        boundingBox.getCenter(center)\n\n        const allIntersections = []\n\n        paths.forEach((path) => {\n          // check if the center of the bounding box is in the bounding box of the paths.\n          // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n          // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n          if (path.boundingBox.containsPoint(center)) {\n            const intersections = getIntersections(scanline, path.points)\n\n            intersections.forEach((p) => {\n              allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p })\n            })\n          }\n        })\n\n        allIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x\n        })\n\n        return allIntersections\n      }\n\n      function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n        if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n          _fillRule = 'nonzero'\n        }\n\n        const centerBoundingBox = new Vector2()\n        simplePath.boundingBox.getCenter(centerBoundingBox)\n\n        const scanline = [\n          new Vector2(scanlineMinX, centerBoundingBox.y),\n          new Vector2(scanlineMaxX, centerBoundingBox.y),\n        ]\n\n        const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths)\n\n        scanlineIntersections.sort((i1, i2) => {\n          return i1.point.x - i2.point.x\n        })\n\n        const baseIntersections = []\n        const otherIntersections = []\n\n        scanlineIntersections.forEach((i) => {\n          if (i.identifier === simplePath.identifier) {\n            baseIntersections.push(i)\n          } else {\n            otherIntersections.push(i)\n          }\n        })\n\n        const firstXOfPath = baseIntersections[0].point.x\n\n        // build up the path hierarchy\n        const stack = []\n        let i = 0\n\n        while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n          if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n            stack.pop()\n          } else {\n            stack.push(otherIntersections[i].identifier)\n          }\n\n          i++\n        }\n\n        stack.push(simplePath.identifier)\n\n        if (_fillRule === 'evenodd') {\n          const isHole = stack.length % 2 === 0 ? true : false\n          const isHoleFor = stack[stack.length - 2]\n\n          return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n        } else if (_fillRule === 'nonzero') {\n          // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n          let isHole = true\n          let isHoleFor = null\n          let lastCWValue = null\n\n          for (let i = 0; i < stack.length; i++) {\n            const identifier = stack[i]\n            if (isHole) {\n              lastCWValue = allPaths[identifier].isCW\n              isHole = false\n              isHoleFor = identifier\n            } else if (lastCWValue !== allPaths[identifier].isCW) {\n              lastCWValue = allPaths[identifier].isCW\n              isHole = true\n            }\n          }\n\n          return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n        } else {\n          console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.')\n        }\n      }\n\n      // check for self intersecting paths\n      // TODO\n\n      // check intersecting paths\n      // TODO\n\n      // prepare paths for hole detection\n      let scanlineMinX = BIGNUMBER\n      let scanlineMaxX = -BIGNUMBER\n\n      let simplePaths = shapePath.subPaths.map((p) => {\n        const points = p.getPoints()\n        let maxY = -BIGNUMBER\n        let minY = BIGNUMBER\n        let maxX = -BIGNUMBER\n        let minX = BIGNUMBER\n\n        //points.forEach(p => p.y *= -1);\n\n        for (let i = 0; i < points.length; i++) {\n          const p = points[i]\n\n          if (p.y > maxY) {\n            maxY = p.y\n          }\n\n          if (p.y < minY) {\n            minY = p.y\n          }\n\n          if (p.x > maxX) {\n            maxX = p.x\n          }\n\n          if (p.x < minX) {\n            minX = p.x\n          }\n        }\n\n        //\n        if (scanlineMaxX <= maxX) {\n          scanlineMaxX = maxX + 1\n        }\n\n        if (scanlineMinX >= minX) {\n          scanlineMinX = minX - 1\n        }\n\n        return {\n          curves: p.curves,\n          points: points,\n          isCW: ShapeUtils.isClockWise(points),\n          identifier: -1,\n          boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)),\n        }\n      })\n\n      simplePaths = simplePaths.filter((sp) => sp.points.length > 1)\n\n      for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n        simplePaths[identifier].identifier = identifier\n      }\n\n      // check if path is solid or a hole\n      const isAHole = simplePaths.map((p) =>\n        isHoleTo(\n          p,\n          simplePaths,\n          scanlineMinX,\n          scanlineMaxX,\n          shapePath.userData ? shapePath.userData.style.fillRule : undefined,\n        ),\n      )\n\n      const shapesToReturn = []\n      simplePaths.forEach((p) => {\n        const amIAHole = isAHole[p.identifier]\n\n        if (!amIAHole.isHole) {\n          const shape = new Shape()\n          shape.curves = p.curves\n          const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier)\n          holes.forEach((h) => {\n            const hole = simplePaths[h.identifier]\n            const path = new Path()\n            path.curves = hole.curves\n            shape.holes.push(path)\n          })\n          shapesToReturn.push(shape)\n        }\n      })\n\n      return shapesToReturn\n    }\n\n    static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n      // Param width: Stroke width\n      // Param color: As returned by THREE.Color.getStyle()\n      // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n      // Param lineCap: One of \"round\", \"square\" or \"butt\"\n      // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n      // Returns style object\n\n      width = width !== undefined ? width : 1\n      color = color !== undefined ? color : '#000'\n      lineJoin = lineJoin !== undefined ? lineJoin : 'miter'\n      lineCap = lineCap !== undefined ? lineCap : 'butt'\n      miterLimit = miterLimit !== undefined ? miterLimit : 4\n\n      return {\n        strokeColor: color,\n        strokeWidth: width,\n        strokeLineJoin: lineJoin,\n        strokeLineCap: lineCap,\n        strokeMiterLimit: miterLimit,\n      }\n    }\n\n    static pointsToStroke(points, style, arcDivisions, minDistance) {\n      // Generates a stroke with some width around the given path.\n      // The path can be open or closed (last point equals to first point)\n      // Param points: Array of Vector2D (the path). Minimum 2 points.\n      // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n      // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n      // Param minDistance: Points closer to this distance will be merged. (Optional)\n      // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n      const vertices = []\n      const normals = []\n      const uvs = []\n\n      if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n        return null\n      }\n\n      const geometry = new BufferGeometry()\n      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n      geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n      geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n      return geometry\n    }\n\n    static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n      // This function can be called to update existing arrays or buffers.\n      // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n      // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n      // Returns number of written vertices / normals / uvs pairs\n      // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n      // 'normals' and 'uvs' buffers are optional\n\n      const tempV2_1 = new Vector2()\n      const tempV2_2 = new Vector2()\n      const tempV2_3 = new Vector2()\n      const tempV2_4 = new Vector2()\n      const tempV2_5 = new Vector2()\n      const tempV2_6 = new Vector2()\n      const tempV2_7 = new Vector2()\n      const lastPointL = new Vector2()\n      const lastPointR = new Vector2()\n      const point0L = new Vector2()\n      const point0R = new Vector2()\n      const currentPointL = new Vector2()\n      const currentPointR = new Vector2()\n      const nextPointL = new Vector2()\n      const nextPointR = new Vector2()\n      const innerPoint = new Vector2()\n      const outerPoint = new Vector2()\n\n      arcDivisions = arcDivisions !== undefined ? arcDivisions : 12\n      minDistance = minDistance !== undefined ? minDistance : 0.001\n      vertexOffset = vertexOffset !== undefined ? vertexOffset : 0\n\n      // First ensure there are no duplicated points\n      points = removeDuplicatedPoints(points)\n\n      const numPoints = points.length\n\n      if (numPoints < 2) return 0\n\n      const isClosed = points[0].equals(points[numPoints - 1])\n\n      let currentPoint\n      let previousPoint = points[0]\n      let nextPoint\n\n      const strokeWidth2 = style.strokeWidth / 2\n\n      const deltaU = 1 / (numPoints - 1)\n      let u0 = 0,\n        u1\n\n      let innerSideModified\n      let joinIsOnLeftSide\n      let isMiter\n      let initialJoinIsOnLeftSide = false\n\n      let numVertices = 0\n      let currentCoordinate = vertexOffset * 3\n      let currentCoordinateUV = vertexOffset * 2\n\n      // Get initial left and right stroke points\n      getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2)\n      lastPointL.copy(points[0]).sub(tempV2_1)\n      lastPointR.copy(points[0]).add(tempV2_1)\n      point0L.copy(lastPointL)\n      point0R.copy(lastPointR)\n\n      for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n        currentPoint = points[iPoint]\n\n        // Get next point\n        if (iPoint === numPoints - 1) {\n          if (isClosed) {\n            // Skip duplicated initial point\n            nextPoint = points[1]\n          } else nextPoint = undefined\n        } else {\n          nextPoint = points[iPoint + 1]\n        }\n\n        // Normal of previous segment in tempV2_1\n        const normal1 = tempV2_1\n        getNormal(previousPoint, currentPoint, normal1)\n\n        tempV2_3.copy(normal1).multiplyScalar(strokeWidth2)\n        currentPointL.copy(currentPoint).sub(tempV2_3)\n        currentPointR.copy(currentPoint).add(tempV2_3)\n\n        u1 = u0 + deltaU\n\n        innerSideModified = false\n\n        if (nextPoint !== undefined) {\n          // Normal of next segment in tempV2_2\n          getNormal(currentPoint, nextPoint, tempV2_2)\n\n          tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2)\n          nextPointL.copy(currentPoint).sub(tempV2_3)\n          nextPointR.copy(currentPoint).add(tempV2_3)\n\n          joinIsOnLeftSide = true\n          tempV2_3.subVectors(nextPoint, previousPoint)\n          if (normal1.dot(tempV2_3) < 0) {\n            joinIsOnLeftSide = false\n          }\n\n          if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide\n\n          tempV2_3.subVectors(nextPoint, currentPoint)\n          tempV2_3.normalize()\n          const dot = Math.abs(normal1.dot(tempV2_3))\n\n          // If path is straight, don't create join\n          if (dot > Number.EPSILON) {\n            // Compute inner and outer segment intersections\n            const miterSide = strokeWidth2 / dot\n            tempV2_3.multiplyScalar(-miterSide)\n            tempV2_4.subVectors(currentPoint, previousPoint)\n            tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3)\n            innerPoint.copy(tempV2_5).negate()\n            const miterLength2 = tempV2_5.length()\n            const segmentLengthPrev = tempV2_4.length()\n            tempV2_4.divideScalar(segmentLengthPrev)\n            tempV2_6.subVectors(nextPoint, currentPoint)\n            const segmentLengthNext = tempV2_6.length()\n            tempV2_6.divideScalar(segmentLengthNext)\n            // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n            if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n              innerSideModified = true\n            }\n\n            outerPoint.copy(tempV2_5).add(currentPoint)\n            innerPoint.add(currentPoint)\n\n            isMiter = false\n\n            if (innerSideModified) {\n              if (joinIsOnLeftSide) {\n                nextPointR.copy(innerPoint)\n                currentPointR.copy(innerPoint)\n              } else {\n                nextPointL.copy(innerPoint)\n                currentPointL.copy(innerPoint)\n              }\n            } else {\n              // The segment triangles are generated here if there was overlapping\n\n              makeSegmentTriangles()\n            }\n\n            switch (style.strokeLineJoin) {\n              case 'bevel':\n                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n\n                break\n\n              case 'round':\n                // Segment triangles\n\n                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                // Join triangles\n\n                if (joinIsOnLeftSide) {\n                  makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0)\n                } else {\n                  makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1)\n                }\n\n                break\n\n              case 'miter':\n              case 'miter-clip':\n              default:\n                const miterFraction = (strokeWidth2 * style.strokeMiterLimit) / miterLength2\n\n                if (miterFraction < 1) {\n                  // The join miter length exceeds the miter limit\n\n                  if (style.strokeLineJoin !== 'miter-clip') {\n                    makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n                    break\n                  } else {\n                    // Segment triangles\n\n                    createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                    // Miter-clip join triangles\n\n                    if (joinIsOnLeftSide) {\n                      tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL)\n                      tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL)\n\n                      addVertex(currentPointL, u1, 0)\n                      addVertex(tempV2_6, u1, 0)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_6, u1, 0)\n                      addVertex(tempV2_7, u1, 0)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_7, u1, 0)\n                      addVertex(nextPointL, u1, 0)\n                    } else {\n                      tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR)\n                      tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR)\n\n                      addVertex(currentPointR, u1, 1)\n                      addVertex(tempV2_6, u1, 1)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_6, u1, 1)\n                      addVertex(tempV2_7, u1, 1)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(tempV2_7, u1, 1)\n                      addVertex(nextPointR, u1, 1)\n                    }\n                  }\n                } else {\n                  // Miter join segment triangles\n\n                  if (innerSideModified) {\n                    // Optimized segment + join triangles\n\n                    if (joinIsOnLeftSide) {\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(outerPoint, u1, 0)\n\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(innerPoint, u1, 1)\n                    } else {\n                      addVertex(lastPointR, u0, 1)\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(outerPoint, u1, 1)\n\n                      addVertex(lastPointL, u0, 0)\n                      addVertex(innerPoint, u1, 0)\n                      addVertex(outerPoint, u1, 1)\n                    }\n\n                    if (joinIsOnLeftSide) {\n                      nextPointL.copy(outerPoint)\n                    } else {\n                      nextPointR.copy(outerPoint)\n                    }\n                  } else {\n                    // Add extra miter join triangles\n\n                    if (joinIsOnLeftSide) {\n                      addVertex(currentPointL, u1, 0)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(outerPoint, u1, 0)\n                      addVertex(nextPointL, u1, 0)\n                    } else {\n                      addVertex(currentPointR, u1, 1)\n                      addVertex(outerPoint, u1, 1)\n                      addVertex(currentPoint, u1, 0.5)\n\n                      addVertex(currentPoint, u1, 0.5)\n                      addVertex(outerPoint, u1, 1)\n                      addVertex(nextPointR, u1, 1)\n                    }\n                  }\n\n                  isMiter = true\n                }\n\n                break\n            }\n          } else {\n            // The segment triangles are generated here when two consecutive points are collinear\n\n            makeSegmentTriangles()\n          }\n        } else {\n          // The segment triangles are generated here if it is the ending segment\n\n          makeSegmentTriangles()\n        }\n\n        if (!isClosed && iPoint === numPoints - 1) {\n          // Start line endcap\n          addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0)\n        }\n\n        // Increment loop variables\n\n        u0 = u1\n\n        previousPoint = currentPoint\n\n        lastPointL.copy(nextPointL)\n        lastPointR.copy(nextPointR)\n      }\n\n      if (!isClosed) {\n        // Ending line endcap\n        addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1)\n      } else if (innerSideModified && vertices) {\n        // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n        let lastOuter = outerPoint\n        let lastInner = innerPoint\n\n        if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n          lastOuter = innerPoint\n          lastInner = outerPoint\n        }\n\n        if (joinIsOnLeftSide) {\n          if (isMiter || initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 0 * 3)\n            lastInner.toArray(vertices, 3 * 3)\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 1 * 3)\n            }\n          }\n        } else {\n          if (isMiter || !initialJoinIsOnLeftSide) {\n            lastInner.toArray(vertices, 1 * 3)\n            lastInner.toArray(vertices, 3 * 3)\n\n            if (isMiter) {\n              lastOuter.toArray(vertices, 0 * 3)\n            }\n          }\n        }\n      }\n\n      return numVertices\n\n      // -- End of algorithm\n\n      // -- Functions\n\n      function getNormal(p1, p2, result) {\n        result.subVectors(p2, p1)\n        return result.set(-result.y, result.x).normalize()\n      }\n\n      function addVertex(position, u, v) {\n        if (vertices) {\n          vertices[currentCoordinate] = position.x\n          vertices[currentCoordinate + 1] = position.y\n          vertices[currentCoordinate + 2] = 0\n\n          if (normals) {\n            normals[currentCoordinate] = 0\n            normals[currentCoordinate + 1] = 0\n            normals[currentCoordinate + 2] = 1\n          }\n\n          currentCoordinate += 3\n\n          if (uvs) {\n            uvs[currentCoordinateUV] = u\n            uvs[currentCoordinateUV + 1] = v\n\n            currentCoordinateUV += 2\n          }\n        }\n\n        numVertices += 3\n      }\n\n      function makeCircularSector(center, p1, p2, u, v) {\n        // param p1, p2: Points in the circle arc.\n        // p1 and p2 are in clockwise direction.\n\n        tempV2_1.copy(p1).sub(center).normalize()\n        tempV2_2.copy(p2).sub(center).normalize()\n\n        let angle = Math.PI\n        const dot = tempV2_1.dot(tempV2_2)\n        if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot))\n\n        angle /= arcDivisions\n\n        tempV2_3.copy(p1)\n\n        for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n          tempV2_4.copy(tempV2_3).rotateAround(center, angle)\n\n          addVertex(tempV2_3, u, v)\n          addVertex(tempV2_4, u, v)\n          addVertex(center, u, 0.5)\n\n          tempV2_3.copy(tempV2_4)\n        }\n\n        addVertex(tempV2_4, u, v)\n        addVertex(p2, u, v)\n        addVertex(center, u, 0.5)\n      }\n\n      function makeSegmentTriangles() {\n        addVertex(lastPointR, u0, 1)\n        addVertex(lastPointL, u0, 0)\n        addVertex(currentPointL, u1, 0)\n\n        addVertex(lastPointR, u0, 1)\n        addVertex(currentPointL, u1, 0)\n        addVertex(currentPointR, u1, 1)\n      }\n\n      function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n        if (innerSideModified) {\n          // Optimized segment + bevel triangles\n\n          if (joinIsOnLeftSide) {\n            // Path segments triangles\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointL, u1, 0)\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(currentPointL, u1, 0)\n            addVertex(innerPoint, u1, 1)\n\n            // Bevel join triangle\n\n            addVertex(currentPointL, u, 0)\n            addVertex(nextPointL, u, 0)\n            addVertex(innerPoint, u, 0.5)\n          } else {\n            // Path segments triangles\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(lastPointL, u0, 0)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPointR, u1, 1)\n\n            // Bevel join triangle\n\n            addVertex(currentPointR, u, 1)\n            addVertex(innerPoint, u, 0)\n            addVertex(nextPointR, u, 1)\n          }\n        } else {\n          // Bevel join triangle. The segment triangles are done in the main loop\n\n          if (joinIsOnLeftSide) {\n            addVertex(currentPointL, u, 0)\n            addVertex(nextPointL, u, 0)\n            addVertex(currentPoint, u, 0.5)\n          } else {\n            addVertex(currentPointR, u, 1)\n            addVertex(nextPointR, u, 0)\n            addVertex(currentPoint, u, 0.5)\n          }\n        }\n      }\n\n      function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n        if (innerSideModified) {\n          if (joinIsOnLeftSide) {\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointL, u1, 0)\n\n            addVertex(lastPointR, u0, 1)\n            addVertex(currentPointL, u1, 0)\n            addVertex(innerPoint, u1, 1)\n\n            addVertex(currentPointL, u0, 0)\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(innerPoint, u1, 1)\n\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(nextPointL, u0, 0)\n            addVertex(innerPoint, u1, 1)\n          } else {\n            addVertex(lastPointR, u0, 1)\n            addVertex(lastPointL, u0, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(lastPointL, u0, 0)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPointR, u1, 1)\n\n            addVertex(currentPointR, u0, 1)\n            addVertex(innerPoint, u1, 0)\n            addVertex(currentPoint, u1, 0.5)\n\n            addVertex(currentPoint, u1, 0.5)\n            addVertex(innerPoint, u1, 0)\n            addVertex(nextPointR, u0, 1)\n          }\n        }\n      }\n\n      function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n        // param center: End point of the path\n        // param p1, p2: Left and right cap points\n\n        switch (style.strokeLineCap) {\n          case 'round':\n            if (start) {\n              makeCircularSector(center, p2, p1, u, 0.5)\n            } else {\n              makeCircularSector(center, p1, p2, u, 0.5)\n            }\n\n            break\n\n          case 'square':\n            if (start) {\n              tempV2_1.subVectors(p1, center)\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n              // Modify already existing vertices\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, 1 * 3)\n                tempV2_4.toArray(vertices, 0 * 3)\n                tempV2_4.toArray(vertices, 3 * 3)\n              } else {\n                tempV2_3.toArray(vertices, 1 * 3)\n                // using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1\n                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3)\n                tempV2_4.toArray(vertices, 0 * 3)\n              }\n            } else {\n              tempV2_1.subVectors(p2, center)\n              tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n              tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n              tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n              const vl = vertices.length\n\n              // Modify already existing vertices\n              if (joinIsOnLeftSide) {\n                tempV2_3.toArray(vertices, vl - 1 * 3)\n                tempV2_4.toArray(vertices, vl - 2 * 3)\n                tempV2_4.toArray(vertices, vl - 4 * 3)\n              } else {\n                tempV2_4.toArray(vertices, vl - 2 * 3)\n                tempV2_3.toArray(vertices, vl - 1 * 3)\n                tempV2_4.toArray(vertices, vl - 4 * 3)\n              }\n            }\n\n            break\n\n          case 'butt':\n          default:\n            // Nothing to do here\n            break\n        }\n      }\n\n      function removeDuplicatedPoints(points) {\n        // Creates a new array if necessary with duplicated points removed.\n        // This does not remove duplicated initial and ending points of a closed path.\n\n        let dupPoints = false\n        for (let i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) < minDistance) {\n            dupPoints = true\n            break\n          }\n        }\n\n        if (!dupPoints) return points\n\n        const newPoints = []\n        newPoints.push(points[0])\n\n        for (let i = 1, n = points.length - 1; i < n; i++) {\n          if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n            newPoints.push(points[i])\n          }\n        }\n\n        newPoints.push(points[points.length - 1])\n\n        return newPoints\n      }\n    }\n  }\n\n  return SVGLoader\n})()\n\nexport { SVGLoader }\n"],"names":["SVGLoader","node","data","i","current","currentTransform","scanlineMinX","scanlineMaxX","p","joinIsOnLeftSide","innerSideModified","points"],"mappings":"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"}},
    {"offset": {"line": 1781, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/_polyfill/constants.js","sources":["file:///Volumes/Space/asian-wires-cables/node_modules/src/_polyfill/constants.ts"],"sourcesContent":["import { REVISION } from 'three'\n\nexport const version = /* @__PURE__ */ (() => parseInt(REVISION.replace(/\\D+/g, '')))()\n"],"names":[],"mappings":";;;;;;AAEa,MAAA,UAAA,aAAA,GAAA,CAAA,IAAiC,SAAS,8JAAA,CAAS,OAAA,CAAQ,QAAQ,EAAE,CAAC,CAAA,EAAG"}},
    {"offset": {"line": 1794, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/objects/GroundProjectedEnv.js","sources":["file:///Volumes/Space/asian-wires-cables/node_modules/src/objects/GroundProjectedEnv.ts"],"sourcesContent":["import { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide, Texture, CubeTexture, BufferGeometry } from 'three'\nimport { version } from '../_polyfill/constants'\n\nexport interface GroundProjectedEnvParameters {\n  height?: number\n  radius?: number\n}\n\nconst isCubeTexture = (def: CubeTexture | Texture): def is CubeTexture => def && (def as CubeTexture).isCubeTexture\n\nexport class GroundProjectedEnv extends Mesh<BufferGeometry, ShaderMaterial> {\n  constructor(texture: CubeTexture | Texture, options?: GroundProjectedEnvParameters) {\n    const isCubeMap = isCubeTexture(texture)\n    const w = (isCubeMap ? texture.image[0]?.width : texture.image.width) ?? 1024\n    const cubeSize = w / 4\n    const _lodMax = Math.floor(Math.log2(cubeSize))\n    const _cubeSize = Math.pow(2, _lodMax)\n    const width = 3 * Math.max(_cubeSize, 16 * 7)\n    const height = 4 * _cubeSize\n\n    const defines = [\n      isCubeMap ? '#define ENVMAP_TYPE_CUBE' : '',\n      `#define CUBEUV_TEXEL_WIDTH ${1.0 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1.0 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`,\n    ]\n\n    const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    const fragmentShader =\n      defines.join('\\n') +\n      /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n        }\n        `\n\n    const uniforms = {\n      map: { value: texture },\n      height: { value: options?.height || 15 },\n      radius: { value: options?.radius || 100 },\n    }\n\n    const geometry = new IcosahedronGeometry(1, 16)\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide,\n    })\n\n    super(geometry, material)\n  }\n\n  set radius(radius: number) {\n    this.material.uniforms.radius.value = radius\n  }\n\n  get radius(): number {\n    return this.material.uniforms.radius.value\n  }\n\n  set height(height: number) {\n    this.material.uniforms.height.value = height\n  }\n\n  get height(): number {\n    return this.material.uniforms.height.value\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAQA,MAAM,gBAAgB,CAAC,MAAmD,OAAQ,IAAoB,aAAA;AAE/F,MAAM,2BAA2B,0JAAA,CAAqC;IAC3E,YAAY,OAAA,EAAgC,OAAA,CAAwC;;QAC5E,MAAA,YAAY,cAAc,OAAO;QACjC,MAAA,IAAA,CAAK,KAAA,YAAA,CAAY,KAAA,QAAQ,KAAA,CAAM,CAAC,CAAA,KAAf,OAAA,KAAA,IAAA,GAAkB,KAAA,GAAQ,QAAQ,KAAA,CAAM,KAAA,KAApD,OAAA,KAA8D;QACzE,MAAM,WAAW,IAAI;QACrB,MAAM,UAAU,KAAK,KAAA,CAAM,KAAK,IAAA,CAAK,QAAQ,CAAC;QAC9C,MAAM,YAAY,KAAK,GAAA,CAAI,GAAG,OAAO;QACrC,MAAM,QAAQ,IAAI,KAAK,GAAA,CAAI,WAAW,KAAK,CAAC;QAC5C,MAAM,SAAS,IAAI;QAEnB,MAAM,UAAU;YACd,YAAY,6BAA6B;YACzC,CAAA,2BAAA,EAA8B,IAAM,OAAA;YACpC,CAAA,4BAAA,EAA+B,IAAM,QAAA;YACrC,CAAA,uBAAA,EAA0B,QAAA,EAAA,CAAA;SAAA;QAGtB,MAAA,eAAA,QAAA,GAA0B,CAAA;;;;;;;;;QAAA,CAAA;QAU1B,MAAA,iBACJ,QAAQ,IAAA,CAAK,IAAI,IAAA,QAAA,GACN,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBAAA,EAqEO,uKAAA,IAAW,MAAM,wBAAwB,qBAAA;;QAAA,CAAA;QAI7D,MAAM,WAAW;YACf,KAAK;gBAAE,OAAO;YAAQ;YACtB,QAAQ;gBAAE,OAAA,CAAO,WAAA,OAAA,KAAA,IAAA,QAAS,MAAA,KAAU;YAAG;YACvC,QAAQ;gBAAE,OAAA,CAAO,WAAA,OAAA,KAAA,IAAA,QAAS,MAAA,KAAU;YAAI;QAAA;QAG1C,MAAM,WAAW,IAAI,yKAAA,CAAoB,GAAG,EAAE;QACxC,MAAA,WAAW,IAAI,oKAAA,CAAe;YAClC;YACA;YACA;YACA,MAAM,gKAAA;QAAA,CACP;QAED,KAAA,CAAM,UAAU,QAAQ;IAC1B;IAEA,IAAI,OAAO,MAAA,EAAgB;QACpB,IAAA,CAAA,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,KAAA,GAAQ;IACxC;IAEA,IAAI,SAAiB;QACZ,OAAA,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,KAAA;IACvC;IAEA,IAAI,OAAO,MAAA,EAAgB;QACpB,IAAA,CAAA,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,KAAA,GAAQ;IACxC;IAEA,IAAI,SAAiB;QACZ,OAAA,IAAA,CAAK,QAAA,CAAS,QAAA,CAAS,MAAA,CAAO,KAAA;IACvC;AACF"}},
    {"offset": {"line": 1940, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/RGBELoader.js","sources":["file:///Volumes/Space/asian-wires-cables/node_modules/src/loaders/RGBELoader.js"],"sourcesContent":["import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearFilter } from 'three'\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n  parse(buffer) {\n    const /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n      rgbe_write_error = 2,\n      rgbe_format_error = 3,\n      rgbe_memory_error = 4,\n      rgbe_error = function (rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            throw new Error('THREE.RGBELoader: Read Error: ' + (msg || ''))\n          case rgbe_write_error:\n            throw new Error('THREE.RGBELoader: Write Error: ' + (msg || ''))\n          case rgbe_format_error:\n            throw new Error('THREE.RGBELoader: Bad File Format: ' + (msg || ''))\n          default:\n          case rgbe_memory_error:\n            throw new Error('THREE.RGBELoader: Memory Error: ' + (msg || ''))\n        }\n      },\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n      RGBE_VALID_FORMAT = 2,\n      RGBE_VALID_DIMENSIONS = 4,\n      NEWLINE = '\\n',\n      fgets = function (buffer, lineLimit, consume) {\n        const chunkSize = 128\n\n        lineLimit = !lineLimit ? 1024 : lineLimit\n        let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n          s += chunk\n          len += chunk.length\n          p += chunkSize\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n          if (false !== consume) buffer.pos += len + i + 1\n          return s + chunk.slice(0, i)\n        }\n\n        return false\n      },\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function (buffer) {\n        // regexes to parse header info fields\n        const magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n          header = {\n            valid: 0 /* indicate which fields are valid */,\n\n            string: '' /* the actual header string */,\n\n            comments: '' /* comments found in header */,\n\n            programtype: 'RGBE' /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */,\n\n            format: '' /* RGBE format, default 32-bit_rle_rgbe */,\n\n            gamma: 1.0 /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */,\n\n            exposure: 1.0 /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */,\n\n            width: 0,\n            height: 0 /* image dimensions, width/height */,\n          }\n\n        let line, match\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          rgbe_error(rgbe_read_error, 'no header found')\n        }\n\n        /* if you want to require the magic token then uncomment the next line */\n        if (!(match = line.match(magic_token_re))) {\n          rgbe_error(rgbe_format_error, 'bad initial token')\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE\n        header.programtype = match[1]\n        header.string += line + '\\n'\n\n        while (true) {\n          line = fgets(buffer)\n          if (false === line) break\n          header.string += line + '\\n'\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n'\n            continue // comment line\n          }\n\n          if ((match = line.match(gamma_re))) {\n            header.gamma = parseFloat(match[1])\n          }\n\n          if ((match = line.match(exposure_re))) {\n            header.exposure = parseFloat(match[1])\n          }\n\n          if ((match = line.match(format_re))) {\n            header.valid |= RGBE_VALID_FORMAT\n            header.format = match[1] //'32-bit_rle_rgbe';\n          }\n\n          if ((match = line.match(dimensions_re))) {\n            header.valid |= RGBE_VALID_DIMENSIONS\n            header.height = parseInt(match[1], 10)\n            header.width = parseInt(match[2], 10)\n          }\n\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          rgbe_error(rgbe_format_error, 'missing format specifier')\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          rgbe_error(rgbe_format_error, 'missing image size specifier')\n        }\n\n        return header\n      },\n      RGBE_ReadPixels_RLE = function (buffer, w, h) {\n        const scanline_width = w\n\n        if (\n          // run length encoding is not allowed so read flat\n          scanline_width < 8 ||\n          scanline_width > 0x7fff ||\n          // this file is not run length encoded\n          2 !== buffer[0] ||\n          2 !== buffer[1] ||\n          buffer[2] & 0x80\n        ) {\n          // return the flat buffer\n          return new Uint8Array(buffer)\n        }\n\n        if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {\n          rgbe_error(rgbe_format_error, 'wrong scanline width')\n        }\n\n        const data_rgba = new Uint8Array(4 * w * h)\n\n        if (!data_rgba.length) {\n          rgbe_error(rgbe_memory_error, 'unable to allocate buffer space')\n        }\n\n        let offset = 0,\n          pos = 0\n\n        const ptr_end = 4 * scanline_width\n        const rgbeStart = new Uint8Array(4)\n        const scanline_buffer = new Uint8Array(ptr_end)\n        let num_scanlines = h\n\n        // read in each successive scanline\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            rgbe_error(rgbe_read_error)\n          }\n\n          rgbeStart[0] = buffer[pos++]\n          rgbeStart[1] = buffer[pos++]\n          rgbeStart[2] = buffer[pos++]\n          rgbeStart[3] = buffer[pos++]\n\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || ((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width) {\n            rgbe_error(rgbe_format_error, 'bad rgbe scanline format')\n          }\n\n          // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n          let ptr = 0,\n            count\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++]\n            const isEncodedRun = count > 128\n            if (isEncodedRun) count -= 128\n\n            if (0 === count || ptr + count > ptr_end) {\n              rgbe_error(rgbe_format_error, 'bad scanline data')\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              const byteValue = buffer[pos++]\n              for (let i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue\n              }\n              //ptr += count;\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr)\n              ptr += count\n              pos += count\n            }\n          }\n\n          // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n          const l = scanline_width //scanline_buffer.byteLength;\n          for (let i = 0; i < l; i++) {\n            let off = 0\n            data_rgba[offset] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 1] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 2] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 3] = scanline_buffer[i + off]\n            offset += 4\n          }\n\n          num_scanlines--\n        }\n\n        return data_rgba\n      }\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale\n      destArray[destOffset + 3] = 1\n    }\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      // clamping to 65504, the maximum representable value in float16\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504))\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504))\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504))\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1)\n    }\n\n    const byteArray = new Uint8Array(buffer)\n    byteArray.pos = 0\n    const rgbe_header_info = RGBE_ReadHeader(byteArray)\n\n    const w = rgbe_header_info.width,\n      h = rgbe_header_info.height,\n      image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h)\n\n    let data, type\n    let numElements\n\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4\n        const floatArray = new Float32Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4)\n        }\n\n        data = floatArray\n        type = FloatType\n        break\n\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4\n        const halfArray = new Uint16Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4)\n        }\n\n        data = halfArray\n        type = HalfFloatType\n        break\n\n      default:\n        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type)\n        break\n    }\n\n    return {\n      width: w,\n      height: h,\n      data: data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type: type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if ('colorSpace' in texture) texture.colorSpace = 'srgb-linear'\n          else texture.encoding = 3000 // LinearEncoding\n          texture.minFilter = LinearFilter\n          texture.magFilter = LinearFilter\n          texture.generateMipmaps = false\n          texture.flipY = true\n\n          break\n      }\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { RGBELoader }\n"],"names":["buffer","w","h"],"mappings":"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"}},
    {"offset": {"line": 2181, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/three-stdlib/loaders/EXRLoader.js","sources":["file:///Volumes/Space/asian-wires-cables/node_modules/src/loaders/EXRLoader.js"],"sourcesContent":["import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { version } from '../_polyfill/constants'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\n// https://github.com/mrdoob/three.js/pull/25771\nconst hasColorSpace = version >= 152\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n"],"names":["uInt8Array","buffer","comp","offset","type","y","x","tmpOffset","EXRHeader","EXRDecoder"],"mappings":"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"}}]
}