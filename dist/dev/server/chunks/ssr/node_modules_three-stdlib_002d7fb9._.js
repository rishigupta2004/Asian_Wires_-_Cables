module.exports = [
"[project]/node_modules/three-stdlib/loaders/SVGLoader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SVGLoader",
    ()=>SVGLoader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
;
const COLOR_SPACE_SVG = "srgb";
const SVGLoader = /* @__PURE__ */ (()=>{
    class SVGLoader2 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Loader"] {
        constructor(manager){
            super(manager);
            this.defaultDPI = 90;
            this.defaultUnit = "px";
        }
        load(url, onLoad, onProgress, onError) {
            const scope = this;
            const loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FileLoader"](scope.manager);
            loader.setPath(scope.path);
            loader.setRequestHeader(scope.requestHeader);
            loader.setWithCredentials(scope.withCredentials);
            loader.load(url, function(text) {
                try {
                    onLoad(scope.parse(text));
                } catch (e) {
                    if (onError) {
                        onError(e);
                    } else {
                        console.error(e);
                    }
                    scope.manager.itemError(url);
                }
            }, onProgress, onError);
        }
        parse(text) {
            const scope = this;
            function parseNode(node, style) {
                if (node.nodeType !== 1) return;
                const transform = getNodeTransform(node);
                let isDefsNode = false;
                let path = null;
                switch(node.nodeName){
                    case "svg":
                        style = parseStyle(node, style);
                        break;
                    case "style":
                        parseCSSStylesheet(node);
                        break;
                    case "g":
                        style = parseStyle(node, style);
                        break;
                    case "path":
                        style = parseStyle(node, style);
                        if (node.hasAttribute("d")) path = parsePathNode(node);
                        break;
                    case "rect":
                        style = parseStyle(node, style);
                        path = parseRectNode(node);
                        break;
                    case "polygon":
                        style = parseStyle(node, style);
                        path = parsePolygonNode(node);
                        break;
                    case "polyline":
                        style = parseStyle(node, style);
                        path = parsePolylineNode(node);
                        break;
                    case "circle":
                        style = parseStyle(node, style);
                        path = parseCircleNode(node);
                        break;
                    case "ellipse":
                        style = parseStyle(node, style);
                        path = parseEllipseNode(node);
                        break;
                    case "line":
                        style = parseStyle(node, style);
                        path = parseLineNode(node);
                        break;
                    case "defs":
                        isDefsNode = true;
                        break;
                    case "use":
                        style = parseStyle(node, style);
                        const href = node.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "";
                        const usedNodeId = href.substring(1);
                        const usedNode = node.viewportElement.getElementById(usedNodeId);
                        if (usedNode) {
                            parseNode(usedNode, style);
                        } else {
                            console.warn("SVGLoader: 'use node' references non-existent node id: " + usedNodeId);
                        }
                        break;
                }
                if (path) {
                    if (style.fill !== void 0 && style.fill !== "none") {
                        path.color.setStyle(style.fill, COLOR_SPACE_SVG);
                    }
                    transformPath(path, currentTransform);
                    paths.push(path);
                    path.userData = {
                        node,
                        style
                    };
                }
                const childNodes = node.childNodes;
                for(let i = 0; i < childNodes.length; i++){
                    const node2 = childNodes[i];
                    if (isDefsNode && node2.nodeName !== "style" && node2.nodeName !== "defs") {
                        continue;
                    }
                    parseNode(node2, style);
                }
                if (transform) {
                    transformStack.pop();
                    if (transformStack.length > 0) {
                        currentTransform.copy(transformStack[transformStack.length - 1]);
                    } else {
                        currentTransform.identity();
                    }
                }
            }
            function parsePathNode(node) {
                const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapePath"]();
                const point = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
                const control = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
                const firstPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
                let isFirstPoint = true;
                let doSetFirstPoint = false;
                const d = node.getAttribute("d");
                if (d === "" || d === "none") return null;
                const commands = d.match(/[a-df-z][^a-df-z]*/gi);
                for(let i = 0, l = commands.length; i < l; i++){
                    const command = commands[i];
                    const type = command.charAt(0);
                    const data2 = command.slice(1).trim();
                    if (isFirstPoint === true) {
                        doSetFirstPoint = true;
                        isFirstPoint = false;
                    }
                    let numbers;
                    switch(type){
                        case "M":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 2){
                                point.x = numbers[j + 0];
                                point.y = numbers[j + 1];
                                control.x = point.x;
                                control.y = point.y;
                                if (j === 0) {
                                    path.moveTo(point.x, point.y);
                                } else {
                                    path.lineTo(point.x, point.y);
                                }
                                if (j === 0) firstPoint.copy(point);
                            }
                            break;
                        case "H":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j++){
                                point.x = numbers[j];
                                control.x = point.x;
                                control.y = point.y;
                                path.lineTo(point.x, point.y);
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "V":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j++){
                                point.y = numbers[j];
                                control.x = point.x;
                                control.y = point.y;
                                path.lineTo(point.x, point.y);
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "L":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 2){
                                point.x = numbers[j + 0];
                                point.y = numbers[j + 1];
                                control.x = point.x;
                                control.y = point.y;
                                path.lineTo(point.x, point.y);
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "C":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 6){
                                path.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);
                                control.x = numbers[j + 2];
                                control.y = numbers[j + 3];
                                point.x = numbers[j + 4];
                                point.y = numbers[j + 5];
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "S":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 4){
                                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);
                                control.x = numbers[j + 0];
                                control.y = numbers[j + 1];
                                point.x = numbers[j + 2];
                                point.y = numbers[j + 3];
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "Q":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 4){
                                path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3]);
                                control.x = numbers[j + 0];
                                control.y = numbers[j + 1];
                                point.x = numbers[j + 2];
                                point.y = numbers[j + 3];
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "T":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 2){
                                const rx = getReflection(point.x, control.x);
                                const ry = getReflection(point.y, control.y);
                                path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1]);
                                control.x = rx;
                                control.y = ry;
                                point.x = numbers[j + 0];
                                point.y = numbers[j + 1];
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "A":
                            numbers = parseFloats(data2, [
                                3,
                                4
                            ], 7);
                            for(let j = 0, jl = numbers.length; j < jl; j += 7){
                                if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue;
                                const start = point.clone();
                                point.x = numbers[j + 5];
                                point.y = numbers[j + 6];
                                control.x = point.x;
                                control.y = point.y;
                                parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "m":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 2){
                                point.x += numbers[j + 0];
                                point.y += numbers[j + 1];
                                control.x = point.x;
                                control.y = point.y;
                                if (j === 0) {
                                    path.moveTo(point.x, point.y);
                                } else {
                                    path.lineTo(point.x, point.y);
                                }
                                if (j === 0) firstPoint.copy(point);
                            }
                            break;
                        case "h":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j++){
                                point.x += numbers[j];
                                control.x = point.x;
                                control.y = point.y;
                                path.lineTo(point.x, point.y);
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "v":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j++){
                                point.y += numbers[j];
                                control.x = point.x;
                                control.y = point.y;
                                path.lineTo(point.x, point.y);
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "l":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 2){
                                point.x += numbers[j + 0];
                                point.y += numbers[j + 1];
                                control.x = point.x;
                                control.y = point.y;
                                path.lineTo(point.x, point.y);
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "c":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 6){
                                path.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);
                                control.x = point.x + numbers[j + 2];
                                control.y = point.y + numbers[j + 3];
                                point.x += numbers[j + 4];
                                point.y += numbers[j + 5];
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "s":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 4){
                                path.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);
                                control.x = point.x + numbers[j + 0];
                                control.y = point.y + numbers[j + 1];
                                point.x += numbers[j + 2];
                                point.y += numbers[j + 3];
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "q":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 4){
                                path.quadraticCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3]);
                                control.x = point.x + numbers[j + 0];
                                control.y = point.y + numbers[j + 1];
                                point.x += numbers[j + 2];
                                point.y += numbers[j + 3];
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "t":
                            numbers = parseFloats(data2);
                            for(let j = 0, jl = numbers.length; j < jl; j += 2){
                                const rx = getReflection(point.x, control.x);
                                const ry = getReflection(point.y, control.y);
                                path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1]);
                                control.x = rx;
                                control.y = ry;
                                point.x = point.x + numbers[j + 0];
                                point.y = point.y + numbers[j + 1];
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "a":
                            numbers = parseFloats(data2, [
                                3,
                                4
                            ], 7);
                            for(let j = 0, jl = numbers.length; j < jl; j += 7){
                                if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue;
                                const start = point.clone();
                                point.x += numbers[j + 5];
                                point.y += numbers[j + 6];
                                control.x = point.x;
                                control.y = point.y;
                                parseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);
                                if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point);
                            }
                            break;
                        case "Z":
                        case "z":
                            path.currentPath.autoClose = true;
                            if (path.currentPath.curves.length > 0) {
                                point.copy(firstPoint);
                                path.currentPath.currentPoint.copy(point);
                                isFirstPoint = true;
                            }
                            break;
                        default:
                            console.warn(command);
                    }
                    doSetFirstPoint = false;
                }
                return path;
            }
            function parseCSSStylesheet(node) {
                if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return;
                for(let i = 0; i < node.sheet.cssRules.length; i++){
                    const stylesheet = node.sheet.cssRules[i];
                    if (stylesheet.type !== 1) continue;
                    const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i2)=>i2.trim());
                    for(let j = 0; j < selectorList.length; j++){
                        const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v])=>v !== ""));
                        stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions);
                    }
                }
            }
            function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {
                if (rx == 0 || ry == 0) {
                    path.lineTo(end.x, end.y);
                    return;
                }
                x_axis_rotation = x_axis_rotation * Math.PI / 180;
                rx = Math.abs(rx);
                ry = Math.abs(ry);
                const dx2 = (start.x - end.x) / 2;
                const dy2 = (start.y - end.y) / 2;
                const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
                const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;
                let rxs = rx * rx;
                let rys = ry * ry;
                const x1ps = x1p * x1p;
                const y1ps = y1p * y1p;
                const cr = x1ps / rxs + y1ps / rys;
                if (cr > 1) {
                    const s = Math.sqrt(cr);
                    rx = s * rx;
                    ry = s * ry;
                    rxs = rx * rx;
                    rys = ry * ry;
                }
                const dq = rxs * y1ps + rys * x1ps;
                const pq = (rxs * rys - dq) / dq;
                let q = Math.sqrt(Math.max(0, pq));
                if (large_arc_flag === sweep_flag) q = -q;
                const cxp = q * rx * y1p / ry;
                const cyp = -q * ry * x1p / rx;
                const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
                const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;
                const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
                const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);
                path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
            }
            function svgAngle(ux, uy, vx, vy) {
                const dot = ux * vx + uy * vy;
                const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
                let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));
                if (ux * vy - uy * vx < 0) ang = -ang;
                return ang;
            }
            function parseRectNode(node) {
                const x = parseFloatWithUnits(node.getAttribute("x") || 0);
                const y = parseFloatWithUnits(node.getAttribute("y") || 0);
                const rx = parseFloatWithUnits(node.getAttribute("rx") || node.getAttribute("ry") || 0);
                const ry = parseFloatWithUnits(node.getAttribute("ry") || node.getAttribute("rx") || 0);
                const w = parseFloatWithUnits(node.getAttribute("width"));
                const h = parseFloatWithUnits(node.getAttribute("height"));
                const bci = 1 - 0.551915024494;
                const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapePath"]();
                path.moveTo(x + rx, y);
                path.lineTo(x + w - rx, y);
                if (rx !== 0 || ry !== 0) {
                    path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry);
                }
                path.lineTo(x + w, y + h - ry);
                if (rx !== 0 || ry !== 0) {
                    path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h);
                }
                path.lineTo(x + rx, y + h);
                if (rx !== 0 || ry !== 0) {
                    path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry);
                }
                path.lineTo(x, y + ry);
                if (rx !== 0 || ry !== 0) {
                    path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y);
                }
                return path;
            }
            function parsePolygonNode(node) {
                function iterator(match, a, b) {
                    const x = parseFloatWithUnits(a);
                    const y = parseFloatWithUnits(b);
                    if (index === 0) {
                        path.moveTo(x, y);
                    } else {
                        path.lineTo(x, y);
                    }
                    index++;
                }
                const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
                const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapePath"]();
                let index = 0;
                node.getAttribute("points").replace(regex, iterator);
                path.currentPath.autoClose = true;
                return path;
            }
            function parsePolylineNode(node) {
                function iterator(match, a, b) {
                    const x = parseFloatWithUnits(a);
                    const y = parseFloatWithUnits(b);
                    if (index === 0) {
                        path.moveTo(x, y);
                    } else {
                        path.lineTo(x, y);
                    }
                    index++;
                }
                const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
                const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapePath"]();
                let index = 0;
                node.getAttribute("points").replace(regex, iterator);
                path.currentPath.autoClose = false;
                return path;
            }
            function parseCircleNode(node) {
                const x = parseFloatWithUnits(node.getAttribute("cx") || 0);
                const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
                const r = parseFloatWithUnits(node.getAttribute("r") || 0);
                const subpath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Path"]();
                subpath.absarc(x, y, r, 0, Math.PI * 2);
                const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapePath"]();
                path.subPaths.push(subpath);
                return path;
            }
            function parseEllipseNode(node) {
                const x = parseFloatWithUnits(node.getAttribute("cx") || 0);
                const y = parseFloatWithUnits(node.getAttribute("cy") || 0);
                const rx = parseFloatWithUnits(node.getAttribute("rx") || 0);
                const ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
                const subpath = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Path"]();
                subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);
                const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapePath"]();
                path.subPaths.push(subpath);
                return path;
            }
            function parseLineNode(node) {
                const x1 = parseFloatWithUnits(node.getAttribute("x1") || 0);
                const y1 = parseFloatWithUnits(node.getAttribute("y1") || 0);
                const x2 = parseFloatWithUnits(node.getAttribute("x2") || 0);
                const y2 = parseFloatWithUnits(node.getAttribute("y2") || 0);
                const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapePath"]();
                path.moveTo(x1, y1);
                path.lineTo(x2, y2);
                path.currentPath.autoClose = false;
                return path;
            }
            function parseStyle(node, style) {
                style = Object.assign({}, style);
                let stylesheetStyles = {};
                if (node.hasAttribute("class")) {
                    const classSelectors = node.getAttribute("class").split(/\s/).filter(Boolean).map((i)=>i.trim());
                    for(let i = 0; i < classSelectors.length; i++){
                        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["." + classSelectors[i]]);
                    }
                }
                if (node.hasAttribute("id")) {
                    stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["#" + node.getAttribute("id")]);
                }
                function addStyle(svgName, jsName, adjustFunction) {
                    if (adjustFunction === void 0) adjustFunction = function copy(v) {
                        if (v.startsWith("url")) console.warn("SVGLoader: url access in attributes is not implemented.");
                        return v;
                    };
                    if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName));
                    if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName]);
                    if (node.style && node.style[svgName] !== "") style[jsName] = adjustFunction(node.style[svgName]);
                }
                function clamp(v) {
                    return Math.max(0, Math.min(1, parseFloatWithUnits(v)));
                }
                function positive(v) {
                    return Math.max(0, parseFloatWithUnits(v));
                }
                addStyle("fill", "fill");
                addStyle("fill-opacity", "fillOpacity", clamp);
                addStyle("fill-rule", "fillRule");
                addStyle("opacity", "opacity", clamp);
                addStyle("stroke", "stroke");
                addStyle("stroke-opacity", "strokeOpacity", clamp);
                addStyle("stroke-width", "strokeWidth", positive);
                addStyle("stroke-linejoin", "strokeLineJoin");
                addStyle("stroke-linecap", "strokeLineCap");
                addStyle("stroke-miterlimit", "strokeMiterLimit", positive);
                addStyle("visibility", "visibility");
                return style;
            }
            function getReflection(a, b) {
                return a - (b - a);
            }
            function parseFloats(input, flags, stride) {
                if (typeof input !== "string") {
                    throw new TypeError("Invalid input: " + typeof input);
                }
                const RE = {
                    SEPARATOR: /[ \t\r\n\,.\-+]/,
                    WHITESPACE: /[ \t\r\n]/,
                    DIGIT: /[\d]/,
                    SIGN: /[-+]/,
                    POINT: /\./,
                    COMMA: /,/,
                    EXP: /e/i,
                    FLAGS: /[01]/
                };
                const SEP = 0;
                const INT = 1;
                const FLOAT = 2;
                const EXP = 3;
                let state = SEP;
                let seenComma = true;
                let number = "", exponent = "";
                const result = [];
                function throwSyntaxError(current2, i, partial) {
                    const error = new SyntaxError('Unexpected character "' + current2 + '" at index ' + i + ".");
                    error.partial = partial;
                    throw error;
                }
                function newNumber() {
                    if (number !== "") {
                        if (exponent === "") result.push(Number(number));
                        else result.push(Number(number) * Math.pow(10, Number(exponent)));
                    }
                    number = "";
                    exponent = "";
                }
                let current;
                const length = input.length;
                for(let i = 0; i < length; i++){
                    current = input[i];
                    if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {
                        state = INT;
                        number = current;
                        newNumber();
                        continue;
                    }
                    if (state === SEP) {
                        if (RE.WHITESPACE.test(current)) {
                            continue;
                        }
                        if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {
                            state = INT;
                            number = current;
                            continue;
                        }
                        if (RE.POINT.test(current)) {
                            state = FLOAT;
                            number = current;
                            continue;
                        }
                        if (RE.COMMA.test(current)) {
                            if (seenComma) {
                                throwSyntaxError(current, i, result);
                            }
                            seenComma = true;
                        }
                    }
                    if (state === INT) {
                        if (RE.DIGIT.test(current)) {
                            number += current;
                            continue;
                        }
                        if (RE.POINT.test(current)) {
                            number += current;
                            state = FLOAT;
                            continue;
                        }
                        if (RE.EXP.test(current)) {
                            state = EXP;
                            continue;
                        }
                        if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {
                            throwSyntaxError(current, i, result);
                        }
                    }
                    if (state === FLOAT) {
                        if (RE.DIGIT.test(current)) {
                            number += current;
                            continue;
                        }
                        if (RE.EXP.test(current)) {
                            state = EXP;
                            continue;
                        }
                        if (RE.POINT.test(current) && number[number.length - 1] === ".") {
                            throwSyntaxError(current, i, result);
                        }
                    }
                    if (state === EXP) {
                        if (RE.DIGIT.test(current)) {
                            exponent += current;
                            continue;
                        }
                        if (RE.SIGN.test(current)) {
                            if (exponent === "") {
                                exponent += current;
                                continue;
                            }
                            if (exponent.length === 1 && RE.SIGN.test(exponent)) {
                                throwSyntaxError(current, i, result);
                            }
                        }
                    }
                    if (RE.WHITESPACE.test(current)) {
                        newNumber();
                        state = SEP;
                        seenComma = false;
                    } else if (RE.COMMA.test(current)) {
                        newNumber();
                        state = SEP;
                        seenComma = true;
                    } else if (RE.SIGN.test(current)) {
                        newNumber();
                        state = INT;
                        number = current;
                    } else if (RE.POINT.test(current)) {
                        newNumber();
                        state = FLOAT;
                        number = current;
                    } else {
                        throwSyntaxError(current, i, result);
                    }
                }
                newNumber();
                return result;
            }
            const units = [
                "mm",
                "cm",
                "in",
                "pt",
                "pc",
                "px"
            ];
            const unitConversion = {
                mm: {
                    mm: 1,
                    cm: 0.1,
                    in: 1 / 25.4,
                    pt: 72 / 25.4,
                    pc: 6 / 25.4,
                    px: -1
                },
                cm: {
                    mm: 10,
                    cm: 1,
                    in: 1 / 2.54,
                    pt: 72 / 2.54,
                    pc: 6 / 2.54,
                    px: -1
                },
                in: {
                    mm: 25.4,
                    cm: 2.54,
                    in: 1,
                    pt: 72,
                    pc: 6,
                    px: -1
                },
                pt: {
                    mm: 25.4 / 72,
                    cm: 2.54 / 72,
                    in: 1 / 72,
                    pt: 1,
                    pc: 6 / 72,
                    px: -1
                },
                pc: {
                    mm: 25.4 / 6,
                    cm: 2.54 / 6,
                    in: 1 / 6,
                    pt: 72 / 6,
                    pc: 1,
                    px: -1
                },
                px: {
                    px: 1
                }
            };
            function parseFloatWithUnits(string) {
                let theUnit = "px";
                if (typeof string === "string" || string instanceof String) {
                    for(let i = 0, n = units.length; i < n; i++){
                        const u = units[i];
                        if (string.endsWith(u)) {
                            theUnit = u;
                            string = string.substring(0, string.length - u.length);
                            break;
                        }
                    }
                }
                let scale = void 0;
                if (theUnit === "px" && scope.defaultUnit !== "px") {
                    scale = unitConversion["in"][scope.defaultUnit] / scope.defaultDPI;
                } else {
                    scale = unitConversion[theUnit][scope.defaultUnit];
                    if (scale < 0) {
                        scale = unitConversion[theUnit]["in"] * scope.defaultDPI;
                    }
                }
                return scale * parseFloat(string);
            }
            function getNodeTransform(node) {
                if (!(node.hasAttribute("transform") || node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y")))) {
                    return null;
                }
                const transform = parseNodeTransform(node);
                if (transformStack.length > 0) {
                    transform.premultiply(transformStack[transformStack.length - 1]);
                }
                currentTransform.copy(transform);
                transformStack.push(transform);
                return transform;
            }
            function parseNodeTransform(node) {
                const transform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix3"]();
                const currentTransform2 = tempTransform0;
                if (node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y"))) {
                    const tx = parseFloatWithUnits(node.getAttribute("x"));
                    const ty = parseFloatWithUnits(node.getAttribute("y"));
                    transform.translate(tx, ty);
                }
                if (node.hasAttribute("transform")) {
                    const transformsTexts = node.getAttribute("transform").split(")");
                    for(let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--){
                        const transformText = transformsTexts[tIndex].trim();
                        if (transformText === "") continue;
                        const openParPos = transformText.indexOf("(");
                        const closeParPos = transformText.length;
                        if (openParPos > 0 && openParPos < closeParPos) {
                            const transformType = transformText.slice(0, openParPos);
                            const array = parseFloats(transformText.slice(openParPos + 1));
                            currentTransform2.identity();
                            switch(transformType){
                                case "translate":
                                    if (array.length >= 1) {
                                        const tx = array[0];
                                        let ty = 0;
                                        if (array.length >= 2) {
                                            ty = array[1];
                                        }
                                        currentTransform2.translate(tx, ty);
                                    }
                                    break;
                                case "rotate":
                                    if (array.length >= 1) {
                                        let angle = 0;
                                        let cx = 0;
                                        let cy = 0;
                                        angle = array[0] * Math.PI / 180;
                                        if (array.length >= 3) {
                                            cx = array[1];
                                            cy = array[2];
                                        }
                                        tempTransform1.makeTranslation(-cx, -cy);
                                        tempTransform2.makeRotation(angle);
                                        tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);
                                        tempTransform1.makeTranslation(cx, cy);
                                        currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);
                                    }
                                    break;
                                case "scale":
                                    if (array.length >= 1) {
                                        const scaleX = array[0];
                                        let scaleY = scaleX;
                                        if (array.length >= 2) {
                                            scaleY = array[1];
                                        }
                                        currentTransform2.scale(scaleX, scaleY);
                                    }
                                    break;
                                case "skewX":
                                    if (array.length === 1) {
                                        currentTransform2.set(1, Math.tan(array[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                                    }
                                    break;
                                case "skewY":
                                    if (array.length === 1) {
                                        currentTransform2.set(1, 0, 0, Math.tan(array[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                                    }
                                    break;
                                case "matrix":
                                    if (array.length === 6) {
                                        currentTransform2.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1);
                                    }
                                    break;
                            }
                        }
                        transform.premultiply(currentTransform2);
                    }
                }
                return transform;
            }
            function transformPath(path, m) {
                function transfVec2(v2) {
                    tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);
                    v2.set(tempV3.x, tempV3.y);
                }
                function transfEllipseGeneric(curve) {
                    const a = curve.xRadius;
                    const b = curve.yRadius;
                    const cosTheta = Math.cos(curve.aRotation);
                    const sinTheta = Math.sin(curve.aRotation);
                    const v1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](a * cosTheta, a * sinTheta, 0);
                    const v2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](-b * sinTheta, b * cosTheta, 0);
                    const f1 = v1.applyMatrix3(m);
                    const f2 = v2.applyMatrix3(m);
                    const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1);
                    const mFInv = tempTransform1.copy(mF).invert();
                    const mFInvT = tempTransform2.copy(mFInv).transpose();
                    const mQ = mFInvT.multiply(mFInv);
                    const mQe = mQ.elements;
                    const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);
                    const rt1sqrt = Math.sqrt(ed.rt1);
                    const rt2sqrt = Math.sqrt(ed.rt2);
                    curve.xRadius = 1 / rt1sqrt;
                    curve.yRadius = 1 / rt2sqrt;
                    curve.aRotation = Math.atan2(ed.sn, ed.cs);
                    const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;
                    if (!isFullEllipse) {
                        const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1);
                        const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1);
                        const mDRF = mDsqrt.multiply(mRT).multiply(mF);
                        const transformAngle = (phi)=>{
                            const { x: cosR, y: sinR } = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"](Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);
                            return Math.atan2(sinR, cosR);
                        };
                        curve.aStartAngle = transformAngle(curve.aStartAngle);
                        curve.aEndAngle = transformAngle(curve.aEndAngle);
                        if (isTransformFlipped(m)) {
                            curve.aClockwise = !curve.aClockwise;
                        }
                    }
                }
                function transfEllipseNoSkew(curve) {
                    const sx = getTransformScaleX(m);
                    const sy = getTransformScaleY(m);
                    curve.xRadius *= sx;
                    curve.yRadius *= sy;
                    const theta = sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);
                    curve.aRotation += theta;
                    if (isTransformFlipped(m)) {
                        curve.aStartAngle *= -1;
                        curve.aEndAngle *= -1;
                        curve.aClockwise = !curve.aClockwise;
                    }
                }
                const subPaths = path.subPaths;
                for(let i = 0, n = subPaths.length; i < n; i++){
                    const subPath = subPaths[i];
                    const curves = subPath.curves;
                    for(let j = 0; j < curves.length; j++){
                        const curve = curves[j];
                        if (curve.isLineCurve) {
                            transfVec2(curve.v1);
                            transfVec2(curve.v2);
                        } else if (curve.isCubicBezierCurve) {
                            transfVec2(curve.v0);
                            transfVec2(curve.v1);
                            transfVec2(curve.v2);
                            transfVec2(curve.v3);
                        } else if (curve.isQuadraticBezierCurve) {
                            transfVec2(curve.v0);
                            transfVec2(curve.v1);
                            transfVec2(curve.v2);
                        } else if (curve.isEllipseCurve) {
                            tempV2.set(curve.aX, curve.aY);
                            transfVec2(tempV2);
                            curve.aX = tempV2.x;
                            curve.aY = tempV2.y;
                            if (isTransformSkewed(m)) {
                                transfEllipseGeneric(curve);
                            } else {
                                transfEllipseNoSkew(curve);
                            }
                        }
                    }
                }
            }
            function isTransformFlipped(m) {
                const te = m.elements;
                return te[0] * te[4] - te[1] * te[3] < 0;
            }
            function isTransformSkewed(m) {
                const te = m.elements;
                const basisDot = te[0] * te[3] + te[1] * te[4];
                if (basisDot === 0) return false;
                const sx = getTransformScaleX(m);
                const sy = getTransformScaleY(m);
                return Math.abs(basisDot / (sx * sy)) > Number.EPSILON;
            }
            function getTransformScaleX(m) {
                const te = m.elements;
                return Math.sqrt(te[0] * te[0] + te[1] * te[1]);
            }
            function getTransformScaleY(m) {
                const te = m.elements;
                return Math.sqrt(te[3] * te[3] + te[4] * te[4]);
            }
            function eigenDecomposition(A, B, C) {
                let rt1, rt2, cs, sn, t;
                const sm = A + C;
                const df = A - C;
                const rt = Math.sqrt(df * df + 4 * B * B);
                if (sm > 0) {
                    rt1 = 0.5 * (sm + rt);
                    t = 1 / rt1;
                    rt2 = A * t * C - B * t * B;
                } else if (sm < 0) {
                    rt2 = 0.5 * (sm - rt);
                } else {
                    rt1 = 0.5 * rt;
                    rt2 = -0.5 * rt;
                }
                if (df > 0) {
                    cs = df + rt;
                } else {
                    cs = df - rt;
                }
                if (Math.abs(cs) > 2 * Math.abs(B)) {
                    t = -2 * B / cs;
                    sn = 1 / Math.sqrt(1 + t * t);
                    cs = t * sn;
                } else if (Math.abs(B) === 0) {
                    cs = 1;
                    sn = 0;
                } else {
                    t = -0.5 * cs / B;
                    cs = 1 / Math.sqrt(1 + t * t);
                    sn = t * cs;
                }
                if (df > 0) {
                    t = cs;
                    cs = -sn;
                    sn = t;
                }
                return {
                    rt1,
                    rt2,
                    cs,
                    sn
                };
            }
            const paths = [];
            const stylesheets = {};
            const transformStack = [];
            const tempTransform0 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix3"]();
            const tempTransform1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix3"]();
            const tempTransform2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix3"]();
            const tempTransform3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix3"]();
            const tempV2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const tempV3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector3"]();
            const currentTransform = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix3"]();
            const xml = new DOMParser().parseFromString(text, "image/svg+xml");
            parseNode(xml.documentElement, {
                fill: "#000",
                fillOpacity: 1,
                strokeOpacity: 1,
                strokeWidth: 1,
                strokeLineJoin: "miter",
                strokeLineCap: "butt",
                strokeMiterLimit: 4
            });
            const data = {
                paths,
                xml: xml.documentElement
            };
            return data;
        }
        static createShapes(shapePath) {
            const BIGNUMBER = 999999999;
            const IntersectionLocationType = {
                ORIGIN: 0,
                DESTINATION: 1,
                BETWEEN: 2,
                LEFT: 3,
                RIGHT: 4,
                BEHIND: 5,
                BEYOND: 6
            };
            const classifyResult = {
                loc: IntersectionLocationType.ORIGIN,
                t: 0
            };
            function findEdgeIntersection(a0, a1, b0, b1) {
                const x1 = a0.x;
                const x2 = a1.x;
                const x3 = b0.x;
                const x4 = b1.x;
                const y1 = a0.y;
                const y2 = a1.y;
                const y3 = b0.y;
                const y4 = b1.y;
                const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
                const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
                const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                const t1 = nom1 / denom;
                const t2 = nom2 / denom;
                if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {
                    return null;
                } else if (nom1 === 0 && denom === 0) {
                    for(let i = 0; i < 2; i++){
                        classifyPoint(i === 0 ? b0 : b1, a0, a1);
                        if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
                            const point = i === 0 ? b0 : b1;
                            return {
                                x: point.x,
                                y: point.y,
                                t: classifyResult.t
                            };
                        } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {
                            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);
                            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10);
                            return {
                                x,
                                y,
                                t: classifyResult.t
                            };
                        }
                    }
                    return null;
                } else {
                    for(let i = 0; i < 2; i++){
                        classifyPoint(i === 0 ? b0 : b1, a0, a1);
                        if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
                            const point = i === 0 ? b0 : b1;
                            return {
                                x: point.x,
                                y: point.y,
                                t: classifyResult.t
                            };
                        }
                    }
                    const x = +(x1 + t1 * (x2 - x1)).toPrecision(10);
                    const y = +(y1 + t1 * (y2 - y1)).toPrecision(10);
                    return {
                        x,
                        y,
                        t: t1
                    };
                }
            }
            function classifyPoint(p, edgeStart, edgeEnd) {
                const ax = edgeEnd.x - edgeStart.x;
                const ay = edgeEnd.y - edgeStart.y;
                const bx = p.x - edgeStart.x;
                const by = p.y - edgeStart.y;
                const sa = ax * by - bx * ay;
                if (p.x === edgeStart.x && p.y === edgeStart.y) {
                    classifyResult.loc = IntersectionLocationType.ORIGIN;
                    classifyResult.t = 0;
                    return;
                }
                if (p.x === edgeEnd.x && p.y === edgeEnd.y) {
                    classifyResult.loc = IntersectionLocationType.DESTINATION;
                    classifyResult.t = 1;
                    return;
                }
                if (sa < -Number.EPSILON) {
                    classifyResult.loc = IntersectionLocationType.LEFT;
                    return;
                }
                if (sa > Number.EPSILON) {
                    classifyResult.loc = IntersectionLocationType.RIGHT;
                    return;
                }
                if (ax * bx < 0 || ay * by < 0) {
                    classifyResult.loc = IntersectionLocationType.BEHIND;
                    return;
                }
                if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {
                    classifyResult.loc = IntersectionLocationType.BEYOND;
                    return;
                }
                let t;
                if (ax !== 0) {
                    t = bx / ax;
                } else {
                    t = by / ay;
                }
                classifyResult.loc = IntersectionLocationType.BETWEEN;
                classifyResult.t = t;
            }
            function getIntersections(path1, path2) {
                const intersectionsRaw = [];
                const intersections = [];
                for(let index = 1; index < path1.length; index++){
                    const path1EdgeStart = path1[index - 1];
                    const path1EdgeEnd = path1[index];
                    for(let index2 = 1; index2 < path2.length; index2++){
                        const path2EdgeStart = path2[index2 - 1];
                        const path2EdgeEnd = path2[index2];
                        const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);
                        if (intersection !== null && intersectionsRaw.find((i)=>i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON) === void 0) {
                            intersectionsRaw.push(intersection);
                            intersections.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](intersection.x, intersection.y));
                        }
                    }
                }
                return intersections;
            }
            function getScanlineIntersections(scanline, boundingBox, paths) {
                const center = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
                boundingBox.getCenter(center);
                const allIntersections = [];
                paths.forEach((path)=>{
                    if (path.boundingBox.containsPoint(center)) {
                        const intersections = getIntersections(scanline, path.points);
                        intersections.forEach((p)=>{
                            allIntersections.push({
                                identifier: path.identifier,
                                isCW: path.isCW,
                                point: p
                            });
                        });
                    }
                });
                allIntersections.sort((i1, i2)=>{
                    return i1.point.x - i2.point.x;
                });
                return allIntersections;
            }
            function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {
                if (_fillRule === null || _fillRule === void 0 || _fillRule === "") {
                    _fillRule = "nonzero";
                }
                const centerBoundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
                simplePath.boundingBox.getCenter(centerBoundingBox);
                const scanline = [
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](scanlineMinX2, centerBoundingBox.y),
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](scanlineMaxX2, centerBoundingBox.y)
                ];
                const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);
                scanlineIntersections.sort((i1, i2)=>{
                    return i1.point.x - i2.point.x;
                });
                const baseIntersections = [];
                const otherIntersections = [];
                scanlineIntersections.forEach((i2)=>{
                    if (i2.identifier === simplePath.identifier) {
                        baseIntersections.push(i2);
                    } else {
                        otherIntersections.push(i2);
                    }
                });
                const firstXOfPath = baseIntersections[0].point.x;
                const stack = [];
                let i = 0;
                while(i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath){
                    if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {
                        stack.pop();
                    } else {
                        stack.push(otherIntersections[i].identifier);
                    }
                    i++;
                }
                stack.push(simplePath.identifier);
                if (_fillRule === "evenodd") {
                    const isHole = stack.length % 2 === 0 ? true : false;
                    const isHoleFor = stack[stack.length - 2];
                    return {
                        identifier: simplePath.identifier,
                        isHole,
                        for: isHoleFor
                    };
                } else if (_fillRule === "nonzero") {
                    let isHole = true;
                    let isHoleFor = null;
                    let lastCWValue = null;
                    for(let i2 = 0; i2 < stack.length; i2++){
                        const identifier = stack[i2];
                        if (isHole) {
                            lastCWValue = allPaths[identifier].isCW;
                            isHole = false;
                            isHoleFor = identifier;
                        } else if (lastCWValue !== allPaths[identifier].isCW) {
                            lastCWValue = allPaths[identifier].isCW;
                            isHole = true;
                        }
                    }
                    return {
                        identifier: simplePath.identifier,
                        isHole,
                        for: isHoleFor
                    };
                } else {
                    console.warn('fill-rule: "' + _fillRule + '" is currently not implemented.');
                }
            }
            let scanlineMinX = BIGNUMBER;
            let scanlineMaxX = -BIGNUMBER;
            let simplePaths = shapePath.subPaths.map((p)=>{
                const points = p.getPoints();
                let maxY = -BIGNUMBER;
                let minY = BIGNUMBER;
                let maxX = -BIGNUMBER;
                let minX = BIGNUMBER;
                for(let i = 0; i < points.length; i++){
                    const p2 = points[i];
                    if (p2.y > maxY) {
                        maxY = p2.y;
                    }
                    if (p2.y < minY) {
                        minY = p2.y;
                    }
                    if (p2.x > maxX) {
                        maxX = p2.x;
                    }
                    if (p2.x < minX) {
                        minX = p2.x;
                    }
                }
                if (scanlineMaxX <= maxX) {
                    scanlineMaxX = maxX + 1;
                }
                if (scanlineMinX >= minX) {
                    scanlineMinX = minX - 1;
                }
                return {
                    curves: p.curves,
                    points,
                    isCW: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShapeUtils"].isClockWise(points),
                    identifier: -1,
                    boundingBox: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Box2"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](minX, minY), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"](maxX, maxY))
                };
            });
            simplePaths = simplePaths.filter((sp)=>sp.points.length > 1);
            for(let identifier = 0; identifier < simplePaths.length; identifier++){
                simplePaths[identifier].identifier = identifier;
            }
            const isAHole = simplePaths.map((p)=>isHoleTo(p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : void 0));
            const shapesToReturn = [];
            simplePaths.forEach((p)=>{
                const amIAHole = isAHole[p.identifier];
                if (!amIAHole.isHole) {
                    const shape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shape"]();
                    shape.curves = p.curves;
                    const holes = isAHole.filter((h)=>h.isHole && h.for === p.identifier);
                    holes.forEach((h)=>{
                        const hole = simplePaths[h.identifier];
                        const path = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Path"]();
                        path.curves = hole.curves;
                        shape.holes.push(path);
                    });
                    shapesToReturn.push(shape);
                }
            });
            return shapesToReturn;
        }
        static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {
            width = width !== void 0 ? width : 1;
            color = color !== void 0 ? color : "#000";
            lineJoin = lineJoin !== void 0 ? lineJoin : "miter";
            lineCap = lineCap !== void 0 ? lineCap : "butt";
            miterLimit = miterLimit !== void 0 ? miterLimit : 4;
            return {
                strokeColor: color,
                strokeWidth: width,
                strokeLineJoin: lineJoin,
                strokeLineCap: lineCap,
                strokeMiterLimit: miterLimit
            };
        }
        static pointsToStroke(points, style, arcDivisions, minDistance) {
            const vertices = [];
            const normals = [];
            const uvs = [];
            if (SVGLoader2.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {
                return null;
            }
            const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BufferGeometry"]();
            geometry.setAttribute("position", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](vertices, 3));
            geometry.setAttribute("normal", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](normals, 3));
            geometry.setAttribute("uv", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](uvs, 2));
            return geometry;
        }
        static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {
            const tempV2_1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const tempV2_2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const tempV2_3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const tempV2_4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const tempV2_5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const tempV2_6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const tempV2_7 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const lastPointL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const lastPointR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const point0L = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const point0R = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const currentPointL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const currentPointR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const nextPointL = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const nextPointR = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const innerPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            const outerPoint = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector2"]();
            arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;
            minDistance = minDistance !== void 0 ? minDistance : 1e-3;
            vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;
            points = removeDuplicatedPoints(points);
            const numPoints = points.length;
            if (numPoints < 2) return 0;
            const isClosed = points[0].equals(points[numPoints - 1]);
            let currentPoint;
            let previousPoint = points[0];
            let nextPoint;
            const strokeWidth2 = style.strokeWidth / 2;
            const deltaU = 1 / (numPoints - 1);
            let u0 = 0, u1;
            let innerSideModified;
            let joinIsOnLeftSide;
            let isMiter;
            let initialJoinIsOnLeftSide = false;
            let numVertices = 0;
            let currentCoordinate = vertexOffset * 3;
            let currentCoordinateUV = vertexOffset * 2;
            getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);
            lastPointL.copy(points[0]).sub(tempV2_1);
            lastPointR.copy(points[0]).add(tempV2_1);
            point0L.copy(lastPointL);
            point0R.copy(lastPointR);
            for(let iPoint = 1; iPoint < numPoints; iPoint++){
                currentPoint = points[iPoint];
                if (iPoint === numPoints - 1) {
                    if (isClosed) {
                        nextPoint = points[1];
                    } else nextPoint = void 0;
                } else {
                    nextPoint = points[iPoint + 1];
                }
                const normal1 = tempV2_1;
                getNormal(previousPoint, currentPoint, normal1);
                tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);
                currentPointL.copy(currentPoint).sub(tempV2_3);
                currentPointR.copy(currentPoint).add(tempV2_3);
                u1 = u0 + deltaU;
                innerSideModified = false;
                if (nextPoint !== void 0) {
                    getNormal(currentPoint, nextPoint, tempV2_2);
                    tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);
                    nextPointL.copy(currentPoint).sub(tempV2_3);
                    nextPointR.copy(currentPoint).add(tempV2_3);
                    joinIsOnLeftSide = true;
                    tempV2_3.subVectors(nextPoint, previousPoint);
                    if (normal1.dot(tempV2_3) < 0) {
                        joinIsOnLeftSide = false;
                    }
                    if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide;
                    tempV2_3.subVectors(nextPoint, currentPoint);
                    tempV2_3.normalize();
                    const dot = Math.abs(normal1.dot(tempV2_3));
                    if (dot > Number.EPSILON) {
                        const miterSide = strokeWidth2 / dot;
                        tempV2_3.multiplyScalar(-miterSide);
                        tempV2_4.subVectors(currentPoint, previousPoint);
                        tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);
                        innerPoint.copy(tempV2_5).negate();
                        const miterLength2 = tempV2_5.length();
                        const segmentLengthPrev = tempV2_4.length();
                        tempV2_4.divideScalar(segmentLengthPrev);
                        tempV2_6.subVectors(nextPoint, currentPoint);
                        const segmentLengthNext = tempV2_6.length();
                        tempV2_6.divideScalar(segmentLengthNext);
                        if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {
                            innerSideModified = true;
                        }
                        outerPoint.copy(tempV2_5).add(currentPoint);
                        innerPoint.add(currentPoint);
                        isMiter = false;
                        if (innerSideModified) {
                            if (joinIsOnLeftSide) {
                                nextPointR.copy(innerPoint);
                                currentPointR.copy(innerPoint);
                            } else {
                                nextPointL.copy(innerPoint);
                                currentPointL.copy(innerPoint);
                            }
                        } else {
                            makeSegmentTriangles();
                        }
                        switch(style.strokeLineJoin){
                            case "bevel":
                                makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                                break;
                            case "round":
                                createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                                if (joinIsOnLeftSide) {
                                    makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);
                                } else {
                                    makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);
                                }
                                break;
                            case "miter":
                            case "miter-clip":
                            default:
                                const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;
                                if (miterFraction < 1) {
                                    if (style.strokeLineJoin !== "miter-clip") {
                                        makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                                        break;
                                    } else {
                                        createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                                        if (joinIsOnLeftSide) {
                                            tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);
                                            tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);
                                            addVertex(currentPointL, u1, 0);
                                            addVertex(tempV2_6, u1, 0);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(tempV2_6, u1, 0);
                                            addVertex(tempV2_7, u1, 0);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(tempV2_7, u1, 0);
                                            addVertex(nextPointL, u1, 0);
                                        } else {
                                            tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);
                                            tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);
                                            addVertex(currentPointR, u1, 1);
                                            addVertex(tempV2_6, u1, 1);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(tempV2_6, u1, 1);
                                            addVertex(tempV2_7, u1, 1);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(tempV2_7, u1, 1);
                                            addVertex(nextPointR, u1, 1);
                                        }
                                    }
                                } else {
                                    if (innerSideModified) {
                                        if (joinIsOnLeftSide) {
                                            addVertex(lastPointR, u0, 1);
                                            addVertex(lastPointL, u0, 0);
                                            addVertex(outerPoint, u1, 0);
                                            addVertex(lastPointR, u0, 1);
                                            addVertex(outerPoint, u1, 0);
                                            addVertex(innerPoint, u1, 1);
                                        } else {
                                            addVertex(lastPointR, u0, 1);
                                            addVertex(lastPointL, u0, 0);
                                            addVertex(outerPoint, u1, 1);
                                            addVertex(lastPointL, u0, 0);
                                            addVertex(innerPoint, u1, 0);
                                            addVertex(outerPoint, u1, 1);
                                        }
                                        if (joinIsOnLeftSide) {
                                            nextPointL.copy(outerPoint);
                                        } else {
                                            nextPointR.copy(outerPoint);
                                        }
                                    } else {
                                        if (joinIsOnLeftSide) {
                                            addVertex(currentPointL, u1, 0);
                                            addVertex(outerPoint, u1, 0);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(outerPoint, u1, 0);
                                            addVertex(nextPointL, u1, 0);
                                        } else {
                                            addVertex(currentPointR, u1, 1);
                                            addVertex(outerPoint, u1, 1);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(currentPoint, u1, 0.5);
                                            addVertex(outerPoint, u1, 1);
                                            addVertex(nextPointR, u1, 1);
                                        }
                                    }
                                    isMiter = true;
                                }
                                break;
                        }
                    } else {
                        makeSegmentTriangles();
                    }
                } else {
                    makeSegmentTriangles();
                }
                if (!isClosed && iPoint === numPoints - 1) {
                    addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);
                }
                u0 = u1;
                previousPoint = currentPoint;
                lastPointL.copy(nextPointL);
                lastPointR.copy(nextPointR);
            }
            if (!isClosed) {
                addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);
            } else if (innerSideModified && vertices) {
                let lastOuter = outerPoint;
                let lastInner = innerPoint;
                if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {
                    lastOuter = innerPoint;
                    lastInner = outerPoint;
                }
                if (joinIsOnLeftSide) {
                    if (isMiter || initialJoinIsOnLeftSide) {
                        lastInner.toArray(vertices, 0 * 3);
                        lastInner.toArray(vertices, 3 * 3);
                        if (isMiter) {
                            lastOuter.toArray(vertices, 1 * 3);
                        }
                    }
                } else {
                    if (isMiter || !initialJoinIsOnLeftSide) {
                        lastInner.toArray(vertices, 1 * 3);
                        lastInner.toArray(vertices, 3 * 3);
                        if (isMiter) {
                            lastOuter.toArray(vertices, 0 * 3);
                        }
                    }
                }
            }
            return numVertices;
            //TURBOPACK unreachable
            ;
            function getNormal(p1, p2, result) {
                result.subVectors(p2, p1);
                return result.set(-result.y, result.x).normalize();
            }
            function addVertex(position, u, v) {
                if (vertices) {
                    vertices[currentCoordinate] = position.x;
                    vertices[currentCoordinate + 1] = position.y;
                    vertices[currentCoordinate + 2] = 0;
                    if (normals) {
                        normals[currentCoordinate] = 0;
                        normals[currentCoordinate + 1] = 0;
                        normals[currentCoordinate + 2] = 1;
                    }
                    currentCoordinate += 3;
                    if (uvs) {
                        uvs[currentCoordinateUV] = u;
                        uvs[currentCoordinateUV + 1] = v;
                        currentCoordinateUV += 2;
                    }
                }
                numVertices += 3;
            }
            function makeCircularSector(center, p1, p2, u, v) {
                tempV2_1.copy(p1).sub(center).normalize();
                tempV2_2.copy(p2).sub(center).normalize();
                let angle = Math.PI;
                const dot = tempV2_1.dot(tempV2_2);
                if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot));
                angle /= arcDivisions;
                tempV2_3.copy(p1);
                for(let i = 0, il = arcDivisions - 1; i < il; i++){
                    tempV2_4.copy(tempV2_3).rotateAround(center, angle);
                    addVertex(tempV2_3, u, v);
                    addVertex(tempV2_4, u, v);
                    addVertex(center, u, 0.5);
                    tempV2_3.copy(tempV2_4);
                }
                addVertex(tempV2_4, u, v);
                addVertex(p2, u, v);
                addVertex(center, u, 0.5);
            }
            function makeSegmentTriangles() {
                addVertex(lastPointR, u0, 1);
                addVertex(lastPointL, u0, 0);
                addVertex(currentPointL, u1, 0);
                addVertex(lastPointR, u0, 1);
                addVertex(currentPointL, u1, 0);
                addVertex(currentPointR, u1, 1);
            }
            function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u) {
                if (innerSideModified2) {
                    if (joinIsOnLeftSide2) {
                        addVertex(lastPointR, u0, 1);
                        addVertex(lastPointL, u0, 0);
                        addVertex(currentPointL, u1, 0);
                        addVertex(lastPointR, u0, 1);
                        addVertex(currentPointL, u1, 0);
                        addVertex(innerPoint, u1, 1);
                        addVertex(currentPointL, u, 0);
                        addVertex(nextPointL, u, 0);
                        addVertex(innerPoint, u, 0.5);
                    } else {
                        addVertex(lastPointR, u0, 1);
                        addVertex(lastPointL, u0, 0);
                        addVertex(currentPointR, u1, 1);
                        addVertex(lastPointL, u0, 0);
                        addVertex(innerPoint, u1, 0);
                        addVertex(currentPointR, u1, 1);
                        addVertex(currentPointR, u, 1);
                        addVertex(innerPoint, u, 0);
                        addVertex(nextPointR, u, 1);
                    }
                } else {
                    if (joinIsOnLeftSide2) {
                        addVertex(currentPointL, u, 0);
                        addVertex(nextPointL, u, 0);
                        addVertex(currentPoint, u, 0.5);
                    } else {
                        addVertex(currentPointR, u, 1);
                        addVertex(nextPointR, u, 0);
                        addVertex(currentPoint, u, 0.5);
                    }
                }
            }
            function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {
                if (innerSideModified2) {
                    if (joinIsOnLeftSide2) {
                        addVertex(lastPointR, u0, 1);
                        addVertex(lastPointL, u0, 0);
                        addVertex(currentPointL, u1, 0);
                        addVertex(lastPointR, u0, 1);
                        addVertex(currentPointL, u1, 0);
                        addVertex(innerPoint, u1, 1);
                        addVertex(currentPointL, u0, 0);
                        addVertex(currentPoint, u1, 0.5);
                        addVertex(innerPoint, u1, 1);
                        addVertex(currentPoint, u1, 0.5);
                        addVertex(nextPointL, u0, 0);
                        addVertex(innerPoint, u1, 1);
                    } else {
                        addVertex(lastPointR, u0, 1);
                        addVertex(lastPointL, u0, 0);
                        addVertex(currentPointR, u1, 1);
                        addVertex(lastPointL, u0, 0);
                        addVertex(innerPoint, u1, 0);
                        addVertex(currentPointR, u1, 1);
                        addVertex(currentPointR, u0, 1);
                        addVertex(innerPoint, u1, 0);
                        addVertex(currentPoint, u1, 0.5);
                        addVertex(currentPoint, u1, 0.5);
                        addVertex(innerPoint, u1, 0);
                        addVertex(nextPointR, u0, 1);
                    }
                }
            }
            function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u) {
                switch(style.strokeLineCap){
                    case "round":
                        if (start) {
                            makeCircularSector(center, p2, p1, u, 0.5);
                        } else {
                            makeCircularSector(center, p1, p2, u, 0.5);
                        }
                        break;
                    case "square":
                        if (start) {
                            tempV2_1.subVectors(p1, center);
                            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
                            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
                            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
                            if (joinIsOnLeftSide2) {
                                tempV2_3.toArray(vertices, 1 * 3);
                                tempV2_4.toArray(vertices, 0 * 3);
                                tempV2_4.toArray(vertices, 3 * 3);
                            } else {
                                tempV2_3.toArray(vertices, 1 * 3);
                                uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);
                                tempV2_4.toArray(vertices, 0 * 3);
                            }
                        } else {
                            tempV2_1.subVectors(p2, center);
                            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
                            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
                            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
                            const vl = vertices.length;
                            if (joinIsOnLeftSide2) {
                                tempV2_3.toArray(vertices, vl - 1 * 3);
                                tempV2_4.toArray(vertices, vl - 2 * 3);
                                tempV2_4.toArray(vertices, vl - 4 * 3);
                            } else {
                                tempV2_4.toArray(vertices, vl - 2 * 3);
                                tempV2_3.toArray(vertices, vl - 1 * 3);
                                tempV2_4.toArray(vertices, vl - 4 * 3);
                            }
                        }
                        break;
                }
            }
            function removeDuplicatedPoints(points2) {
                let dupPoints = false;
                for(let i = 1, n = points2.length - 1; i < n; i++){
                    if (points2[i].distanceTo(points2[i + 1]) < minDistance) {
                        dupPoints = true;
                        break;
                    }
                }
                if (!dupPoints) return points2;
                const newPoints = [];
                newPoints.push(points2[0]);
                for(let i = 1, n = points2.length - 1; i < n; i++){
                    if (points2[i].distanceTo(points2[i + 1]) >= minDistance) {
                        newPoints.push(points2[i]);
                    }
                }
                newPoints.push(points2[points2.length - 1]);
                return newPoints;
            }
        }
    }
    return SVGLoader2;
})();
;
 //# sourceMappingURL=SVGLoader.js.map
}),
"[project]/node_modules/three-stdlib/_polyfill/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "version",
    ()=>version
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
;
const version = /* @__PURE__ */ (()=>parseInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["REVISION"].replace(/\D+/g, "")))();
;
 //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/three-stdlib/objects/GroundProjectedEnv.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GroundProjectedEnv",
    ()=>GroundProjectedEnv
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-ssr] (ecmascript)");
;
;
const isCubeTexture = (def)=>def && def.isCubeTexture;
class GroundProjectedEnv extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(texture, options){
        var _a, _b;
        const isCubeMap = isCubeTexture(texture);
        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;
        const cubeSize = w / 4;
        const _lodMax = Math.floor(Math.log2(cubeSize));
        const _cubeSize = Math.pow(2, _lodMax);
        const width = 3 * Math.max(_cubeSize, 16 * 7);
        const height = 4 * _cubeSize;
        const defines = [
            isCubeMap ? "#define ENVMAP_TYPE_CUBE" : "",
            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,
            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,
            `#define CUBEUV_MAX_MIP ${_lodMax}.0`
        ];
        const vertexShader = /* glsl */ `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `;
        const fragmentShader = defines.join("\n") + /* glsl */ `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"] >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }
        `;
        const uniforms = {
            map: {
                value: texture
            },
            height: {
                value: (options == null ? void 0 : options.height) || 15
            },
            radius: {
                value: (options == null ? void 0 : options.radius) || 100
            }
        };
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["IcosahedronGeometry"](1, 16);
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            uniforms,
            fragmentShader,
            vertexShader,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DoubleSide"]
        });
        super(geometry, material);
    }
    set radius(radius) {
        this.material.uniforms.radius.value = radius;
    }
    get radius() {
        return this.material.uniforms.radius.value;
    }
    set height(height) {
        this.material.uniforms.height.value = height;
    }
    get height() {
        return this.material.uniforms.height.value;
    }
}
;
 //# sourceMappingURL=GroundProjectedEnv.js.map
}),
"[project]/node_modules/three-stdlib/loaders/RGBELoader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RGBELoader",
    ()=>RGBELoader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
;
class RGBELoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataTextureLoader"] {
    constructor(manager){
        super(manager);
        this.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"];
    }
    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
    parse(buffer) {
        const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {
            switch(rgbe_error_code){
                case rgbe_read_error:
                    throw new Error("THREE.RGBELoader: Read Error: " + (msg || ""));
                case rgbe_write_error:
                    throw new Error("THREE.RGBELoader: Write Error: " + (msg || ""));
                case rgbe_format_error:
                    throw new Error("THREE.RGBELoader: Bad File Format: " + (msg || ""));
                default:
                case rgbe_memory_error:
                    throw new Error("THREE.RGBELoader: Memory Error: " + (msg || ""));
            }
        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = "\n", fgets = function(buffer2, lineLimit, consume) {
            const chunkSize = 128;
            lineLimit = !lineLimit ? 1024 : lineLimit;
            let p = buffer2.pos, i = -1, len = 0, s = "", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){
                s += chunk;
                len += chunk.length;
                p += chunkSize;
                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));
            }
            if (-1 < i) {
                if (false !== consume) buffer2.pos += len + i + 1;
                return s + chunk.slice(0, i);
            }
            return false;
        }, RGBE_ReadHeader = function(buffer2) {
            const magic_token_re = /^#\?(\S+)/, gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, format_re = /^\s*FORMAT=(\S+)\s*$/, dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, header = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let line, match;
            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {
                rgbe_error(rgbe_read_error, "no header found");
            }
            if (!(match = line.match(magic_token_re))) {
                rgbe_error(rgbe_format_error, "bad initial token");
            }
            header.valid |= RGBE_VALID_PROGRAMTYPE;
            header.programtype = match[1];
            header.string += line + "\n";
            while(true){
                line = fgets(buffer2);
                if (false === line) break;
                header.string += line + "\n";
                if ("#" === line.charAt(0)) {
                    header.comments += line + "\n";
                    continue;
                }
                if (match = line.match(gamma_re)) {
                    header.gamma = parseFloat(match[1]);
                }
                if (match = line.match(exposure_re)) {
                    header.exposure = parseFloat(match[1]);
                }
                if (match = line.match(format_re)) {
                    header.valid |= RGBE_VALID_FORMAT;
                    header.format = match[1];
                }
                if (match = line.match(dimensions_re)) {
                    header.valid |= RGBE_VALID_DIMENSIONS;
                    header.height = parseInt(match[1], 10);
                    header.width = parseInt(match[2], 10);
                }
                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;
            }
            if (!(header.valid & RGBE_VALID_FORMAT)) {
                rgbe_error(rgbe_format_error, "missing format specifier");
            }
            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {
                rgbe_error(rgbe_format_error, "missing image size specifier");
            }
            return header;
        }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {
            const scanline_width = w2;
            if (// run length encoding is not allowed so read flat
            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded
            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {
                return new Uint8Array(buffer2);
            }
            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {
                rgbe_error(rgbe_format_error, "wrong scanline width");
            }
            const data_rgba = new Uint8Array(4 * w2 * h2);
            if (!data_rgba.length) {
                rgbe_error(rgbe_memory_error, "unable to allocate buffer space");
            }
            let offset = 0, pos = 0;
            const ptr_end = 4 * scanline_width;
            const rgbeStart = new Uint8Array(4);
            const scanline_buffer = new Uint8Array(ptr_end);
            let num_scanlines = h2;
            while(num_scanlines > 0 && pos < buffer2.byteLength){
                if (pos + 4 > buffer2.byteLength) {
                    rgbe_error(rgbe_read_error);
                }
                rgbeStart[0] = buffer2[pos++];
                rgbeStart[1] = buffer2[pos++];
                rgbeStart[2] = buffer2[pos++];
                rgbeStart[3] = buffer2[pos++];
                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {
                    rgbe_error(rgbe_format_error, "bad rgbe scanline format");
                }
                let ptr = 0, count;
                while(ptr < ptr_end && pos < buffer2.byteLength){
                    count = buffer2[pos++];
                    const isEncodedRun = count > 128;
                    if (isEncodedRun) count -= 128;
                    if (0 === count || ptr + count > ptr_end) {
                        rgbe_error(rgbe_format_error, "bad scanline data");
                    }
                    if (isEncodedRun) {
                        const byteValue = buffer2[pos++];
                        for(let i = 0; i < count; i++){
                            scanline_buffer[ptr++] = byteValue;
                        }
                    } else {
                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);
                        ptr += count;
                        pos += count;
                    }
                }
                const l = scanline_width;
                for(let i = 0; i < l; i++){
                    let off = 0;
                    data_rgba[offset] = scanline_buffer[i + off];
                    off += scanline_width;
                    data_rgba[offset + 1] = scanline_buffer[i + off];
                    off += scanline_width;
                    data_rgba[offset + 2] = scanline_buffer[i + off];
                    off += scanline_width;
                    data_rgba[offset + 3] = scanline_buffer[i + off];
                    offset += 4;
                }
                num_scanlines--;
            }
            return data_rgba;
        };
        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {
            const e = sourceArray[sourceOffset + 3];
            const scale = Math.pow(2, e - 128) / 255;
            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;
            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;
            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;
            destArray[destOffset + 3] = 1;
        };
        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {
            const e = sourceArray[sourceOffset + 3];
            const scale = Math.pow(2, e - 128) / 255;
            destArray[destOffset + 0] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));
            destArray[destOffset + 1] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));
            destArray[destOffset + 2] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));
            destArray[destOffset + 3] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(1);
        };
        const byteArray = new Uint8Array(buffer);
        byteArray.pos = 0;
        const rgbe_header_info = RGBE_ReadHeader(byteArray);
        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);
        let data, type;
        let numElements;
        switch(this.type){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FloatType"]:
                numElements = image_rgba_data.length / 4;
                const floatArray = new Float32Array(numElements * 4);
                for(let j = 0; j < numElements; j++){
                    RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);
                }
                data = floatArray;
                type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FloatType"];
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                numElements = image_rgba_data.length / 4;
                const halfArray = new Uint16Array(numElements * 4);
                for(let j = 0; j < numElements; j++){
                    RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);
                }
                data = halfArray;
                type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"];
                break;
            default:
                throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
        }
        return {
            width: w,
            height: h,
            data,
            header: rgbe_header_info.string,
            gamma: rgbe_header_info.gamma,
            exposure: rgbe_header_info.exposure,
            type
        };
    }
    setDataType(value) {
        this.type = value;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        function onLoadCallback(texture, texData) {
            switch(texture.type){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FloatType"]:
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                    if ("colorSpace" in texture) texture.colorSpace = "srgb-linear";
                    else texture.encoding = 3e3;
                    texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LinearFilter"];
                    texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LinearFilter"];
                    texture.generateMipmaps = false;
                    texture.flipY = true;
                    break;
            }
            if (onLoad) onLoad(texture, texData);
        }
        return super.load(url, onLoadCallback, onProgress, onError);
    }
}
;
 //# sourceMappingURL=RGBELoader.js.map
}),
"[project]/node_modules/three-stdlib/loaders/EXRLoader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "EXRLoader",
    ()=>EXRLoader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.core.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/node_modules/fflate/esm/index.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three-stdlib/_polyfill/constants.js [app-ssr] (ecmascript)");
;
;
;
const hasColorSpace = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$_polyfill$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"] >= 152;
class EXRLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataTextureLoader"] {
    constructor(manager){
        super(manager);
        this.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"];
    }
    parse(buffer) {
        const USHORT_RANGE = 1 << 16;
        const BITMAP_SIZE = USHORT_RANGE >> 3;
        const HUF_ENCBITS = 16;
        const HUF_DECBITS = 14;
        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;
        const HUF_DECSIZE = 1 << HUF_DECBITS;
        const HUF_DECMASK = HUF_DECSIZE - 1;
        const NBITS = 16;
        const A_OFFSET = 1 << NBITS - 1;
        const MOD_MASK = (1 << NBITS) - 1;
        const SHORT_ZEROCODE_RUN = 59;
        const LONG_ZEROCODE_RUN = 63;
        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;
        const ULONG_SIZE = 8;
        const FLOAT32_SIZE = 4;
        const INT32_SIZE = 4;
        const INT16_SIZE = 2;
        const INT8_SIZE = 1;
        const STATIC_HUFFMAN = 0;
        const DEFLATE = 1;
        const UNKNOWN = 0;
        const LOSSY_DCT = 1;
        const RLE = 2;
        const logBase = Math.pow(2.7182818, 2.2);
        function reverseLutFromBitmap(bitmap, lut) {
            var k = 0;
            for(var i = 0; i < USHORT_RANGE; ++i){
                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {
                    lut[k++] = i;
                }
            }
            var n = k - 1;
            while(k < USHORT_RANGE)lut[k++] = 0;
            return n;
        }
        function hufClearDecTable(hdec) {
            for(var i = 0; i < HUF_DECSIZE; i++){
                hdec[i] = {};
                hdec[i].len = 0;
                hdec[i].lit = 0;
                hdec[i].p = null;
            }
        }
        const getBitsReturn = {
            l: 0,
            c: 0,
            lc: 0
        };
        function getBits(nBits, c, lc, uInt8Array2, inOffset) {
            while(lc < nBits){
                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
                lc += 8;
            }
            lc -= nBits;
            getBitsReturn.l = c >> lc & (1 << nBits) - 1;
            getBitsReturn.c = c;
            getBitsReturn.lc = lc;
        }
        const hufTableBuffer = new Array(59);
        function hufCanonicalCodeTable(hcode) {
            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;
            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;
            var c = 0;
            for(var i = 58; i > 0; --i){
                var nc = c + hufTableBuffer[i] >> 1;
                hufTableBuffer[i] = c;
                c = nc;
            }
            for(var i = 0; i < HUF_ENCSIZE; ++i){
                var l = hcode[i];
                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;
            }
        }
        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {
            var p = inOffset;
            var c = 0;
            var lc = 0;
            for(; im <= iM; im++){
                if (p.value - inOffset.value > ni) return false;
                getBits(6, c, lc, uInt8Array2, p);
                var l = getBitsReturn.l;
                c = getBitsReturn.c;
                lc = getBitsReturn.lc;
                hcode[im] = l;
                if (l == LONG_ZEROCODE_RUN) {
                    if (p.value - inOffset.value > ni) {
                        throw "Something wrong with hufUnpackEncTable";
                    }
                    getBits(8, c, lc, uInt8Array2, p);
                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;
                    c = getBitsReturn.c;
                    lc = getBitsReturn.lc;
                    if (im + zerun > iM + 1) {
                        throw "Something wrong with hufUnpackEncTable";
                    }
                    while(zerun--)hcode[im++] = 0;
                    im--;
                } else if (l >= SHORT_ZEROCODE_RUN) {
                    var zerun = l - SHORT_ZEROCODE_RUN + 2;
                    if (im + zerun > iM + 1) {
                        throw "Something wrong with hufUnpackEncTable";
                    }
                    while(zerun--)hcode[im++] = 0;
                    im--;
                }
            }
            hufCanonicalCodeTable(hcode);
        }
        function hufLength(code) {
            return code & 63;
        }
        function hufCode(code) {
            return code >> 6;
        }
        function hufBuildDecTable(hcode, im, iM, hdecod) {
            for(; im <= iM; im++){
                var c = hufCode(hcode[im]);
                var l = hufLength(hcode[im]);
                if (c >> l) {
                    throw "Invalid table entry";
                }
                if (l > HUF_DECBITS) {
                    var pl = hdecod[c >> l - HUF_DECBITS];
                    if (pl.len) {
                        throw "Invalid table entry";
                    }
                    pl.lit++;
                    if (pl.p) {
                        var p = pl.p;
                        pl.p = new Array(pl.lit);
                        for(var i = 0; i < pl.lit - 1; ++i){
                            pl.p[i] = p[i];
                        }
                    } else {
                        pl.p = new Array(1);
                    }
                    pl.p[pl.lit - 1] = im;
                } else if (l) {
                    var plOffset = 0;
                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){
                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];
                        if (pl.len || pl.p) {
                            throw "Invalid table entry";
                        }
                        pl.len = l;
                        pl.lit = im;
                        plOffset++;
                    }
                }
            }
            return true;
        }
        const getCharReturn = {
            c: 0,
            lc: 0
        };
        function getChar(c, lc, uInt8Array2, inOffset) {
            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);
            lc += 8;
            getCharReturn.c = c;
            getCharReturn.lc = lc;
        }
        const getCodeReturn = {
            c: 0,
            lc: 0
        };
        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {
            if (po == rlc) {
                if (lc < 8) {
                    getChar(c, lc, uInt8Array2, inOffset);
                    c = getCharReturn.c;
                    lc = getCharReturn.lc;
                }
                lc -= 8;
                var cs = c >> lc;
                var cs = new Uint8Array([
                    cs
                ])[0];
                if (outBufferOffset.value + cs > outBufferEndOffset) {
                    return false;
                }
                var s = outBuffer[outBufferOffset.value - 1];
                while(cs-- > 0){
                    outBuffer[outBufferOffset.value++] = s;
                }
            } else if (outBufferOffset.value < outBufferEndOffset) {
                outBuffer[outBufferOffset.value++] = po;
            } else {
                return false;
            }
            getCodeReturn.c = c;
            getCodeReturn.lc = lc;
        }
        function UInt16(value) {
            return value & 65535;
        }
        function Int16(value) {
            var ref = UInt16(value);
            return ref > 32767 ? ref - 65536 : ref;
        }
        const wdec14Return = {
            a: 0,
            b: 0
        };
        function wdec14(l, h) {
            var ls = Int16(l);
            var hs = Int16(h);
            var hi = hs;
            var ai = ls + (hi & 1) + (hi >> 1);
            var as = ai;
            var bs = ai - hi;
            wdec14Return.a = as;
            wdec14Return.b = bs;
        }
        function wdec16(l, h) {
            var m = UInt16(l);
            var d = UInt16(h);
            var bb = m - (d >> 1) & MOD_MASK;
            var aa = d + bb - A_OFFSET & MOD_MASK;
            wdec14Return.a = aa;
            wdec14Return.b = bb;
        }
        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {
            var w14 = mx < 1 << 14;
            var n = nx > ny ? ny : nx;
            var p = 1;
            var p2;
            while(p <= n)p <<= 1;
            p >>= 1;
            p2 = p;
            p >>= 1;
            while(p >= 1){
                var py = 0;
                var ey = py + oy * (ny - p2);
                var oy1 = oy * p;
                var oy2 = oy * p2;
                var ox1 = ox * p;
                var ox2 = ox * p2;
                var i00, i01, i10, i11;
                for(; py <= ey; py += oy2){
                    var px = py;
                    var ex = py + ox * (nx - p2);
                    for(; px <= ex; px += ox2){
                        var p01 = px + ox1;
                        var p10 = px + oy1;
                        var p11 = p10 + ox1;
                        if (w14) {
                            wdec14(buffer2[px + j], buffer2[p10 + j]);
                            i00 = wdec14Return.a;
                            i10 = wdec14Return.b;
                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);
                            i01 = wdec14Return.a;
                            i11 = wdec14Return.b;
                            wdec14(i00, i01);
                            buffer2[px + j] = wdec14Return.a;
                            buffer2[p01 + j] = wdec14Return.b;
                            wdec14(i10, i11);
                            buffer2[p10 + j] = wdec14Return.a;
                            buffer2[p11 + j] = wdec14Return.b;
                        } else {
                            wdec16(buffer2[px + j], buffer2[p10 + j]);
                            i00 = wdec14Return.a;
                            i10 = wdec14Return.b;
                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);
                            i01 = wdec14Return.a;
                            i11 = wdec14Return.b;
                            wdec16(i00, i01);
                            buffer2[px + j] = wdec14Return.a;
                            buffer2[p01 + j] = wdec14Return.b;
                            wdec16(i10, i11);
                            buffer2[p10 + j] = wdec14Return.a;
                            buffer2[p11 + j] = wdec14Return.b;
                        }
                    }
                    if (nx & p) {
                        var p10 = px + oy1;
                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);
                        else wdec16(buffer2[px + j], buffer2[p10 + j]);
                        i00 = wdec14Return.a;
                        buffer2[p10 + j] = wdec14Return.b;
                        buffer2[px + j] = i00;
                    }
                }
                if (ny & p) {
                    var px = py;
                    var ex = py + ox * (nx - p2);
                    for(; px <= ex; px += ox2){
                        var p01 = px + ox1;
                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);
                        else wdec16(buffer2[px + j], buffer2[p01 + j]);
                        i00 = wdec14Return.a;
                        buffer2[p01 + j] = wdec14Return.b;
                        buffer2[px + j] = i00;
                    }
                }
                p2 = p;
                p >>= 1;
            }
            return py;
        }
        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {
            var c = 0;
            var lc = 0;
            var outBufferEndOffset = no;
            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);
            while(inOffset.value < inOffsetEnd){
                getChar(c, lc, uInt8Array2, inOffset);
                c = getCharReturn.c;
                lc = getCharReturn.lc;
                while(lc >= HUF_DECBITS){
                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;
                    var pl = decodingTable[index];
                    if (pl.len) {
                        lc -= pl.len;
                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                        c = getCodeReturn.c;
                        lc = getCodeReturn.lc;
                    } else {
                        if (!pl.p) {
                            throw "hufDecode issues";
                        }
                        var j;
                        for(j = 0; j < pl.lit; j++){
                            var l = hufLength(encodingTable[pl.p[j]]);
                            while(lc < l && inOffset.value < inOffsetEnd){
                                getChar(c, lc, uInt8Array2, inOffset);
                                c = getCharReturn.c;
                                lc = getCharReturn.lc;
                            }
                            if (lc >= l) {
                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {
                                    lc -= l;
                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                                    c = getCodeReturn.c;
                                    lc = getCodeReturn.lc;
                                    break;
                                }
                            }
                        }
                        if (j == pl.lit) {
                            throw "hufDecode issues";
                        }
                    }
                }
            }
            var i = 8 - ni & 7;
            c >>= i;
            lc -= i;
            while(lc > 0){
                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];
                if (pl.len) {
                    lc -= pl.len;
                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);
                    c = getCodeReturn.c;
                    lc = getCodeReturn.lc;
                } else {
                    throw "hufDecode issues";
                }
            }
            return true;
        }
        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {
            var outOffset = {
                value: 0
            };
            var initialInOffset = inOffset.value;
            var im = parseUint32(inDataView, inOffset);
            var iM = parseUint32(inDataView, inOffset);
            inOffset.value += 4;
            var nBits = parseUint32(inDataView, inOffset);
            inOffset.value += 4;
            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {
                throw "Something wrong with HUF_ENCSIZE";
            }
            var freq = new Array(HUF_ENCSIZE);
            var hdec = new Array(HUF_DECSIZE);
            hufClearDecTable(hdec);
            var ni = nCompressed - (inOffset.value - initialInOffset);
            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);
            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {
                throw "Something wrong with hufUncompress";
            }
            hufBuildDecTable(freq, im, iM, hdec);
            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);
        }
        function applyLut(lut, data, nData) {
            for(var i = 0; i < nData; ++i){
                data[i] = lut[data[i]];
            }
        }
        function predictor(source) {
            for(var t = 1; t < source.length; t++){
                var d = source[t - 1] + source[t] - 128;
                source[t] = d;
            }
        }
        function interleaveScalar(source, out) {
            var t1 = 0;
            var t2 = Math.floor((source.length + 1) / 2);
            var s = 0;
            var stop = source.length - 1;
            while(true){
                if (s > stop) break;
                out[s++] = source[t1++];
                if (s > stop) break;
                out[s++] = source[t2++];
            }
        }
        function decodeRunLength(source) {
            var size = source.byteLength;
            var out = new Array();
            var p = 0;
            var reader = new DataView(source);
            while(size > 0){
                var l = reader.getInt8(p++);
                if (l < 0) {
                    var count = -l;
                    size -= count + 1;
                    for(var i = 0; i < count; i++){
                        out.push(reader.getUint8(p++));
                    }
                } else {
                    var count = l;
                    size -= 2;
                    var value = reader.getUint8(p++);
                    for(var i = 0; i < count + 1; i++){
                        out.push(value);
                    }
                }
            }
            return out;
        }
        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {
            var dataView = new DataView(outBuffer.buffer);
            var width = channelData[cscSet.idx[0]].width;
            var height = channelData[cscSet.idx[0]].height;
            var numComp = 3;
            var numFullBlocksX = Math.floor(width / 8);
            var numBlocksX = Math.ceil(width / 8);
            var numBlocksY = Math.ceil(height / 8);
            var leftoverX = width - (numBlocksX - 1) * 8;
            var leftoverY = height - (numBlocksY - 1) * 8;
            var currAcComp = {
                value: 0
            };
            var currDcComp = new Array(numComp);
            var dctData = new Array(numComp);
            var halfZigBlock = new Array(numComp);
            var rowBlock = new Array(numComp);
            var rowOffsets = new Array(numComp);
            for(let comp2 = 0; comp2 < numComp; ++comp2){
                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];
                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;
                dctData[comp2] = new Float32Array(64);
                halfZigBlock[comp2] = new Uint16Array(64);
                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);
            }
            for(let blocky = 0; blocky < numBlocksY; ++blocky){
                var maxY = 8;
                if (blocky == numBlocksY - 1) maxY = leftoverY;
                var maxX = 8;
                for(let blockx = 0; blockx < numBlocksX; ++blockx){
                    if (blockx == numBlocksX - 1) maxX = leftoverX;
                    for(let comp2 = 0; comp2 < numComp; ++comp2){
                        halfZigBlock[comp2].fill(0);
                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];
                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);
                        unZigZag(halfZigBlock[comp2], dctData[comp2]);
                        dctInverse(dctData[comp2]);
                    }
                    {
                        csc709Inverse(dctData);
                    }
                    for(let comp2 = 0; comp2 < numComp; ++comp2){
                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);
                    }
                }
                let offset2 = 0;
                for(let comp2 = 0; comp2 < numComp; ++comp2){
                    const type2 = channelData[cscSet.idx[comp2]].type;
                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){
                        offset2 = rowOffsets[comp2][y2];
                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){
                            const src = blockx * 64 + (y2 & 7) * 8;
                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);
                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);
                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);
                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);
                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);
                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);
                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);
                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);
                            offset2 += 8 * INT16_SIZE * type2;
                        }
                    }
                    if (numFullBlocksX != numBlocksX) {
                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){
                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;
                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;
                            for(let x2 = 0; x2 < maxX; ++x2){
                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);
                            }
                        }
                    }
                }
            }
            var halfRow = new Uint16Array(width);
            var dataView = new DataView(outBuffer.buffer);
            for(var comp = 0; comp < numComp; ++comp){
                channelData[cscSet.idx[comp]].decoded = true;
                var type = channelData[cscSet.idx[comp]].type;
                if (channelData[comp].type != 2) continue;
                for(var y = 0; y < height; ++y){
                    const offset2 = rowOffsets[comp][y];
                    for(var x = 0; x < width; ++x){
                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);
                    }
                    for(var x = 0; x < width; ++x){
                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);
                    }
                }
            }
        }
        function unRleAC(currAcComp, acBuffer, halfZigBlock) {
            var acValue;
            var dctComp = 1;
            while(dctComp < 64){
                acValue = acBuffer[currAcComp.value];
                if (acValue == 65280) {
                    dctComp = 64;
                } else if (acValue >> 8 == 255) {
                    dctComp += acValue & 255;
                } else {
                    halfZigBlock[dctComp] = acValue;
                    dctComp++;
                }
                currAcComp.value++;
            }
        }
        function unZigZag(src, dst) {
            dst[0] = decodeFloat16(src[0]);
            dst[1] = decodeFloat16(src[1]);
            dst[2] = decodeFloat16(src[5]);
            dst[3] = decodeFloat16(src[6]);
            dst[4] = decodeFloat16(src[14]);
            dst[5] = decodeFloat16(src[15]);
            dst[6] = decodeFloat16(src[27]);
            dst[7] = decodeFloat16(src[28]);
            dst[8] = decodeFloat16(src[2]);
            dst[9] = decodeFloat16(src[4]);
            dst[10] = decodeFloat16(src[7]);
            dst[11] = decodeFloat16(src[13]);
            dst[12] = decodeFloat16(src[16]);
            dst[13] = decodeFloat16(src[26]);
            dst[14] = decodeFloat16(src[29]);
            dst[15] = decodeFloat16(src[42]);
            dst[16] = decodeFloat16(src[3]);
            dst[17] = decodeFloat16(src[8]);
            dst[18] = decodeFloat16(src[12]);
            dst[19] = decodeFloat16(src[17]);
            dst[20] = decodeFloat16(src[25]);
            dst[21] = decodeFloat16(src[30]);
            dst[22] = decodeFloat16(src[41]);
            dst[23] = decodeFloat16(src[43]);
            dst[24] = decodeFloat16(src[9]);
            dst[25] = decodeFloat16(src[11]);
            dst[26] = decodeFloat16(src[18]);
            dst[27] = decodeFloat16(src[24]);
            dst[28] = decodeFloat16(src[31]);
            dst[29] = decodeFloat16(src[40]);
            dst[30] = decodeFloat16(src[44]);
            dst[31] = decodeFloat16(src[53]);
            dst[32] = decodeFloat16(src[10]);
            dst[33] = decodeFloat16(src[19]);
            dst[34] = decodeFloat16(src[23]);
            dst[35] = decodeFloat16(src[32]);
            dst[36] = decodeFloat16(src[39]);
            dst[37] = decodeFloat16(src[45]);
            dst[38] = decodeFloat16(src[52]);
            dst[39] = decodeFloat16(src[54]);
            dst[40] = decodeFloat16(src[20]);
            dst[41] = decodeFloat16(src[22]);
            dst[42] = decodeFloat16(src[33]);
            dst[43] = decodeFloat16(src[38]);
            dst[44] = decodeFloat16(src[46]);
            dst[45] = decodeFloat16(src[51]);
            dst[46] = decodeFloat16(src[55]);
            dst[47] = decodeFloat16(src[60]);
            dst[48] = decodeFloat16(src[21]);
            dst[49] = decodeFloat16(src[34]);
            dst[50] = decodeFloat16(src[37]);
            dst[51] = decodeFloat16(src[47]);
            dst[52] = decodeFloat16(src[50]);
            dst[53] = decodeFloat16(src[56]);
            dst[54] = decodeFloat16(src[59]);
            dst[55] = decodeFloat16(src[61]);
            dst[56] = decodeFloat16(src[35]);
            dst[57] = decodeFloat16(src[36]);
            dst[58] = decodeFloat16(src[48]);
            dst[59] = decodeFloat16(src[49]);
            dst[60] = decodeFloat16(src[57]);
            dst[61] = decodeFloat16(src[58]);
            dst[62] = decodeFloat16(src[62]);
            dst[63] = decodeFloat16(src[63]);
        }
        function dctInverse(data) {
            const a = 0.5 * Math.cos(3.14159 / 4);
            const b = 0.5 * Math.cos(3.14159 / 16);
            const c = 0.5 * Math.cos(3.14159 / 8);
            const d = 0.5 * Math.cos(3 * 3.14159 / 16);
            const e = 0.5 * Math.cos(5 * 3.14159 / 16);
            const f = 0.5 * Math.cos(3 * 3.14159 / 8);
            const g = 0.5 * Math.cos(7 * 3.14159 / 16);
            var alpha = new Array(4);
            var beta = new Array(4);
            var theta = new Array(4);
            var gamma = new Array(4);
            for(var row = 0; row < 8; ++row){
                var rowPtr = row * 8;
                alpha[0] = c * data[rowPtr + 2];
                alpha[1] = f * data[rowPtr + 2];
                alpha[2] = c * data[rowPtr + 6];
                alpha[3] = f * data[rowPtr + 6];
                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];
                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];
                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];
                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];
                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);
                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);
                theta[1] = alpha[0] + alpha[3];
                theta[2] = alpha[1] - alpha[2];
                gamma[0] = theta[0] + theta[1];
                gamma[1] = theta[3] + theta[2];
                gamma[2] = theta[3] - theta[2];
                gamma[3] = theta[0] - theta[1];
                data[rowPtr + 0] = gamma[0] + beta[0];
                data[rowPtr + 1] = gamma[1] + beta[1];
                data[rowPtr + 2] = gamma[2] + beta[2];
                data[rowPtr + 3] = gamma[3] + beta[3];
                data[rowPtr + 4] = gamma[3] - beta[3];
                data[rowPtr + 5] = gamma[2] - beta[2];
                data[rowPtr + 6] = gamma[1] - beta[1];
                data[rowPtr + 7] = gamma[0] - beta[0];
            }
            for(var column = 0; column < 8; ++column){
                alpha[0] = c * data[16 + column];
                alpha[1] = f * data[16 + column];
                alpha[2] = c * data[48 + column];
                alpha[3] = f * data[48 + column];
                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];
                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];
                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];
                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];
                theta[0] = a * (data[column] + data[32 + column]);
                theta[3] = a * (data[column] - data[32 + column]);
                theta[1] = alpha[0] + alpha[3];
                theta[2] = alpha[1] - alpha[2];
                gamma[0] = theta[0] + theta[1];
                gamma[1] = theta[3] + theta[2];
                gamma[2] = theta[3] - theta[2];
                gamma[3] = theta[0] - theta[1];
                data[0 + column] = gamma[0] + beta[0];
                data[8 + column] = gamma[1] + beta[1];
                data[16 + column] = gamma[2] + beta[2];
                data[24 + column] = gamma[3] + beta[3];
                data[32 + column] = gamma[3] - beta[3];
                data[40 + column] = gamma[2] - beta[2];
                data[48 + column] = gamma[1] - beta[1];
                data[56 + column] = gamma[0] - beta[0];
            }
        }
        function csc709Inverse(data) {
            for(var i = 0; i < 64; ++i){
                var y = data[0][i];
                var cb = data[1][i];
                var cr = data[2][i];
                data[0][i] = y + 1.5747 * cr;
                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;
                data[2][i] = y + 1.8556 * cb;
            }
        }
        function convertToHalf(src, dst, idx) {
            for(var i = 0; i < 64; ++i){
                dst[idx + i] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(toLinear(src[i]));
            }
        }
        function toLinear(float) {
            if (float <= 1) {
                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);
            } else {
                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);
            }
        }
        function uncompressRAW(info) {
            return new DataView(info.array.buffer, info.offset.value, info.size);
        }
        function uncompressRLE(info) {
            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);
            var rawBuffer = new Uint8Array(decodeRunLength(compressed));
            var tmpBuffer = new Uint8Array(rawBuffer.length);
            predictor(rawBuffer);
            interleaveScalar(rawBuffer, tmpBuffer);
            return new DataView(tmpBuffer.buffer);
        }
        function uncompressZIP(info) {
            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
            var rawBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
            var tmpBuffer = new Uint8Array(rawBuffer.length);
            predictor(rawBuffer);
            interleaveScalar(rawBuffer, tmpBuffer);
            return new DataView(tmpBuffer.buffer);
        }
        function uncompressPIZ(info) {
            var inDataView = info.viewer;
            var inOffset = {
                value: info.offset.value
            };
            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));
            var bitmap = new Uint8Array(BITMAP_SIZE);
            var outBufferEnd = 0;
            var pizChannelData = new Array(info.channels);
            for(var i = 0; i < info.channels; i++){
                pizChannelData[i] = {};
                pizChannelData[i]["start"] = outBufferEnd;
                pizChannelData[i]["end"] = pizChannelData[i]["start"];
                pizChannelData[i]["nx"] = info.width;
                pizChannelData[i]["ny"] = info.lines;
                pizChannelData[i]["size"] = info.type;
                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;
            }
            var minNonZero = parseUint16(inDataView, inOffset);
            var maxNonZero = parseUint16(inDataView, inOffset);
            if (maxNonZero >= BITMAP_SIZE) {
                throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
            }
            if (minNonZero <= maxNonZero) {
                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){
                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);
                }
            }
            var lut = new Uint16Array(USHORT_RANGE);
            var maxValue = reverseLutFromBitmap(bitmap, lut);
            var length = parseUint32(inDataView, inOffset);
            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);
            for(var i = 0; i < info.channels; ++i){
                var cd = pizChannelData[i];
                for(var j = 0; j < pizChannelData[i].size; ++j){
                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);
                }
            }
            applyLut(lut, outBuffer, outBufferEnd);
            var tmpOffset2 = 0;
            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);
            for(var y = 0; y < info.lines; y++){
                for(var c = 0; c < info.channels; c++){
                    var cd = pizChannelData[c];
                    var n = cd.nx * cd.size;
                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);
                    tmpBuffer.set(cp, tmpOffset2);
                    tmpOffset2 += n * INT16_SIZE;
                    cd.end += n;
                }
            }
            return new DataView(tmpBuffer.buffer);
        }
        function uncompressPXR(info) {
            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);
            var rawBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
            const sz = info.lines * info.channels * info.width;
            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);
            let tmpBufferEnd = 0;
            let writePtr = 0;
            const ptr = new Array(4);
            for(let y = 0; y < info.lines; y++){
                for(let c = 0; c < info.channels; c++){
                    let pixel = 0;
                    switch(info.type){
                        case 1:
                            ptr[0] = tmpBufferEnd;
                            ptr[1] = ptr[0] + info.width;
                            tmpBufferEnd = ptr[1] + info.width;
                            for(let j = 0; j < info.width; ++j){
                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];
                                pixel += diff;
                                tmpBuffer[writePtr] = pixel;
                                writePtr++;
                            }
                            break;
                        case 2:
                            ptr[0] = tmpBufferEnd;
                            ptr[1] = ptr[0] + info.width;
                            ptr[2] = ptr[1] + info.width;
                            tmpBufferEnd = ptr[2] + info.width;
                            for(let j = 0; j < info.width; ++j){
                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;
                                pixel += diff;
                                tmpBuffer[writePtr] = pixel;
                                writePtr++;
                            }
                            break;
                    }
                }
            }
            return new DataView(tmpBuffer.buffer);
        }
        function uncompressDWA(info) {
            var inDataView = info.viewer;
            var inOffset = {
                value: info.offset.value
            };
            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));
            var dwaHeader = {
                version: parseInt64(inDataView, inOffset),
                unknownUncompressedSize: parseInt64(inDataView, inOffset),
                unknownCompressedSize: parseInt64(inDataView, inOffset),
                acCompressedSize: parseInt64(inDataView, inOffset),
                dcCompressedSize: parseInt64(inDataView, inOffset),
                rleCompressedSize: parseInt64(inDataView, inOffset),
                rleUncompressedSize: parseInt64(inDataView, inOffset),
                rleRawSize: parseInt64(inDataView, inOffset),
                totalAcUncompressedCount: parseInt64(inDataView, inOffset),
                totalDcUncompressedCount: parseInt64(inDataView, inOffset),
                acCompression: parseInt64(inDataView, inOffset)
            };
            if (dwaHeader.version < 2) {
                throw "EXRLoader.parse: " + EXRHeader.compression + " version " + dwaHeader.version + " is unsupported";
            }
            var channelRules = new Array();
            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;
            while(ruleSize > 0){
                var name = parseNullTerminatedString(inDataView.buffer, inOffset);
                var value = parseUint8(inDataView, inOffset);
                var compression = value >> 2 & 3;
                var csc = (value >> 4) - 1;
                var index = new Int8Array([
                    csc
                ])[0];
                var type = parseUint8(inDataView, inOffset);
                channelRules.push({
                    name,
                    index,
                    type,
                    compression
                });
                ruleSize -= name.length + 3;
            }
            var channels = EXRHeader.channels;
            var channelData = new Array(info.channels);
            for(var i = 0; i < info.channels; ++i){
                var cd = channelData[i] = {};
                var channel = channels[i];
                cd.name = channel.name;
                cd.compression = UNKNOWN;
                cd.decoded = false;
                cd.type = channel.pixelType;
                cd.pLinear = channel.pLinear;
                cd.width = info.width;
                cd.height = info.lines;
            }
            var cscSet = {
                idx: new Array(3)
            };
            for(var offset2 = 0; offset2 < info.channels; ++offset2){
                var cd = channelData[offset2];
                for(var i = 0; i < channelRules.length; ++i){
                    var rule = channelRules[i];
                    if (cd.name == rule.name) {
                        cd.compression = rule.compression;
                        if (rule.index >= 0) {
                            cscSet.idx[rule.index] = offset2;
                        }
                        cd.offset = offset2;
                    }
                }
            }
            if (dwaHeader.acCompressedSize > 0) {
                switch(dwaHeader.acCompression){
                    case STATIC_HUFFMAN:
                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);
                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);
                        break;
                    case DEFLATE:
                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);
                        var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
                        var acBuffer = new Uint16Array(data.buffer);
                        inOffset.value += dwaHeader.totalAcUncompressedCount;
                        break;
                }
            }
            if (dwaHeader.dcCompressedSize > 0) {
                var zlibInfo = {
                    array: info.array,
                    offset: inOffset,
                    size: dwaHeader.dcCompressedSize
                };
                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);
                inOffset.value += dwaHeader.dcCompressedSize;
            }
            if (dwaHeader.rleRawSize > 0) {
                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);
                var data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2d$stdlib$2f$node_modules$2f$fflate$2f$esm$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unzlibSync"])(compressed);
                var rleBuffer = decodeRunLength(data.buffer);
                inOffset.value += dwaHeader.rleCompressedSize;
            }
            var outBufferEnd = 0;
            var rowOffsets = new Array(channelData.length);
            for(var i = 0; i < rowOffsets.length; ++i){
                rowOffsets[i] = new Array();
            }
            for(var y = 0; y < info.lines; ++y){
                for(var chan = 0; chan < channelData.length; ++chan){
                    rowOffsets[chan].push(outBufferEnd);
                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;
                }
            }
            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);
            for(var i = 0; i < channelData.length; ++i){
                var cd = channelData[i];
                if (cd.decoded) continue;
                switch(cd.compression){
                    case RLE:
                        var row = 0;
                        var rleOffset = 0;
                        for(var y = 0; y < info.lines; ++y){
                            var rowOffsetBytes = rowOffsets[i][row];
                            for(var x = 0; x < cd.width; ++x){
                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){
                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];
                                }
                                rleOffset++;
                            }
                            row++;
                        }
                        break;
                    case LOSSY_DCT:
                    default:
                        throw "EXRLoader.parse: unsupported channel compression";
                }
            }
            return new DataView(outBuffer.buffer);
        }
        function parseNullTerminatedString(buffer2, offset2) {
            var uintBuffer = new Uint8Array(buffer2);
            var endOffset = 0;
            while(uintBuffer[offset2.value + endOffset] != 0){
                endOffset += 1;
            }
            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));
            offset2.value = offset2.value + endOffset + 1;
            return stringValue;
        }
        function parseFixedLengthString(buffer2, offset2, size) {
            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));
            offset2.value = offset2.value + size;
            return stringValue;
        }
        function parseRational(dataView, offset2) {
            var x = parseInt32(dataView, offset2);
            var y = parseUint32(dataView, offset2);
            return [
                x,
                y
            ];
        }
        function parseTimecode(dataView, offset2) {
            var x = parseUint32(dataView, offset2);
            var y = parseUint32(dataView, offset2);
            return [
                x,
                y
            ];
        }
        function parseInt32(dataView, offset2) {
            var Int32 = dataView.getInt32(offset2.value, true);
            offset2.value = offset2.value + INT32_SIZE;
            return Int32;
        }
        function parseUint32(dataView, offset2) {
            var Uint32 = dataView.getUint32(offset2.value, true);
            offset2.value = offset2.value + INT32_SIZE;
            return Uint32;
        }
        function parseUint8Array(uInt8Array2, offset2) {
            var Uint8 = uInt8Array2[offset2.value];
            offset2.value = offset2.value + INT8_SIZE;
            return Uint8;
        }
        function parseUint8(dataView, offset2) {
            var Uint8 = dataView.getUint8(offset2.value);
            offset2.value = offset2.value + INT8_SIZE;
            return Uint8;
        }
        const parseInt64 = function(dataView, offset2) {
            let int;
            if ("getBigInt64" in DataView.prototype) {
                int = Number(dataView.getBigInt64(offset2.value, true));
            } else {
                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);
            }
            offset2.value += ULONG_SIZE;
            return int;
        };
        function parseFloat32(dataView, offset2) {
            var float = dataView.getFloat32(offset2.value, true);
            offset2.value += FLOAT32_SIZE;
            return float;
        }
        function decodeFloat32(dataView, offset2) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataUtils"].toHalfFloat(parseFloat32(dataView, offset2));
        }
        function decodeFloat16(binary) {
            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;
            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));
        }
        function parseUint16(dataView, offset2) {
            var Uint16 = dataView.getUint16(offset2.value, true);
            offset2.value += INT16_SIZE;
            return Uint16;
        }
        function parseFloat16(buffer2, offset2) {
            return decodeFloat16(parseUint16(buffer2, offset2));
        }
        function parseChlist(dataView, buffer2, offset2, size) {
            var startOffset = offset2.value;
            var channels = [];
            while(offset2.value < startOffset + size - 1){
                var name = parseNullTerminatedString(buffer2, offset2);
                var pixelType = parseInt32(dataView, offset2);
                var pLinear = parseUint8(dataView, offset2);
                offset2.value += 3;
                var xSampling = parseInt32(dataView, offset2);
                var ySampling = parseInt32(dataView, offset2);
                channels.push({
                    name,
                    pixelType,
                    pLinear,
                    xSampling,
                    ySampling
                });
            }
            offset2.value += 1;
            return channels;
        }
        function parseChromaticities(dataView, offset2) {
            var redX = parseFloat32(dataView, offset2);
            var redY = parseFloat32(dataView, offset2);
            var greenX = parseFloat32(dataView, offset2);
            var greenY = parseFloat32(dataView, offset2);
            var blueX = parseFloat32(dataView, offset2);
            var blueY = parseFloat32(dataView, offset2);
            var whiteX = parseFloat32(dataView, offset2);
            var whiteY = parseFloat32(dataView, offset2);
            return {
                redX,
                redY,
                greenX,
                greenY,
                blueX,
                blueY,
                whiteX,
                whiteY
            };
        }
        function parseCompression(dataView, offset2) {
            var compressionCodes = [
                "NO_COMPRESSION",
                "RLE_COMPRESSION",
                "ZIPS_COMPRESSION",
                "ZIP_COMPRESSION",
                "PIZ_COMPRESSION",
                "PXR24_COMPRESSION",
                "B44_COMPRESSION",
                "B44A_COMPRESSION",
                "DWAA_COMPRESSION",
                "DWAB_COMPRESSION"
            ];
            var compression = parseUint8(dataView, offset2);
            return compressionCodes[compression];
        }
        function parseBox2i(dataView, offset2) {
            var xMin = parseUint32(dataView, offset2);
            var yMin = parseUint32(dataView, offset2);
            var xMax = parseUint32(dataView, offset2);
            var yMax = parseUint32(dataView, offset2);
            return {
                xMin,
                yMin,
                xMax,
                yMax
            };
        }
        function parseLineOrder(dataView, offset2) {
            var lineOrders = [
                "INCREASING_Y"
            ];
            var lineOrder = parseUint8(dataView, offset2);
            return lineOrders[lineOrder];
        }
        function parseV2f(dataView, offset2) {
            var x = parseFloat32(dataView, offset2);
            var y = parseFloat32(dataView, offset2);
            return [
                x,
                y
            ];
        }
        function parseV3f(dataView, offset2) {
            var x = parseFloat32(dataView, offset2);
            var y = parseFloat32(dataView, offset2);
            var z = parseFloat32(dataView, offset2);
            return [
                x,
                y,
                z
            ];
        }
        function parseValue(dataView, buffer2, offset2, type, size) {
            if (type === "string" || type === "stringvector" || type === "iccProfile") {
                return parseFixedLengthString(buffer2, offset2, size);
            } else if (type === "chlist") {
                return parseChlist(dataView, buffer2, offset2, size);
            } else if (type === "chromaticities") {
                return parseChromaticities(dataView, offset2);
            } else if (type === "compression") {
                return parseCompression(dataView, offset2);
            } else if (type === "box2i") {
                return parseBox2i(dataView, offset2);
            } else if (type === "lineOrder") {
                return parseLineOrder(dataView, offset2);
            } else if (type === "float") {
                return parseFloat32(dataView, offset2);
            } else if (type === "v2f") {
                return parseV2f(dataView, offset2);
            } else if (type === "v3f") {
                return parseV3f(dataView, offset2);
            } else if (type === "int") {
                return parseInt32(dataView, offset2);
            } else if (type === "rational") {
                return parseRational(dataView, offset2);
            } else if (type === "timecode") {
                return parseTimecode(dataView, offset2);
            } else if (type === "preview") {
                offset2.value += size;
                return "skipped";
            } else {
                offset2.value += size;
                return void 0;
            }
        }
        function parseHeader(dataView, buffer2, offset2) {
            const EXRHeader2 = {};
            if (dataView.getUint32(0, true) != 20000630) {
                throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
            }
            EXRHeader2.version = dataView.getUint8(4);
            const spec = dataView.getUint8(5);
            EXRHeader2.spec = {
                singleTile: !!(spec & 2),
                longName: !!(spec & 4),
                deepFormat: !!(spec & 8),
                multiPart: !!(spec & 16)
            };
            offset2.value = 8;
            var keepReading = true;
            while(keepReading){
                var attributeName = parseNullTerminatedString(buffer2, offset2);
                if (attributeName == 0) {
                    keepReading = false;
                } else {
                    var attributeType = parseNullTerminatedString(buffer2, offset2);
                    var attributeSize = parseUint32(dataView, offset2);
                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);
                    if (attributeValue === void 0) {
                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);
                    } else {
                        EXRHeader2[attributeName] = attributeValue;
                    }
                }
            }
            if ((spec & ~4) != 0) {
                console.error("EXRHeader:", EXRHeader2);
                throw "THREE.EXRLoader: provided file is currently unsupported.";
            }
            return EXRHeader2;
        }
        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {
            const EXRDecoder2 = {
                size: 0,
                viewer: dataView,
                array: uInt8Array2,
                offset: offset2,
                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,
                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,
                channels: EXRHeader2.channels.length,
                bytesPerLine: null,
                lines: null,
                inputSize: null,
                type: EXRHeader2.channels[0].pixelType,
                uncompress: null,
                getter: null,
                format: null,
                [hasColorSpace ? "colorSpace" : "encoding"]: null
            };
            switch(EXRHeader2.compression){
                case "NO_COMPRESSION":
                    EXRDecoder2.lines = 1;
                    EXRDecoder2.uncompress = uncompressRAW;
                    break;
                case "RLE_COMPRESSION":
                    EXRDecoder2.lines = 1;
                    EXRDecoder2.uncompress = uncompressRLE;
                    break;
                case "ZIPS_COMPRESSION":
                    EXRDecoder2.lines = 1;
                    EXRDecoder2.uncompress = uncompressZIP;
                    break;
                case "ZIP_COMPRESSION":
                    EXRDecoder2.lines = 16;
                    EXRDecoder2.uncompress = uncompressZIP;
                    break;
                case "PIZ_COMPRESSION":
                    EXRDecoder2.lines = 32;
                    EXRDecoder2.uncompress = uncompressPIZ;
                    break;
                case "PXR24_COMPRESSION":
                    EXRDecoder2.lines = 16;
                    EXRDecoder2.uncompress = uncompressPXR;
                    break;
                case "DWAA_COMPRESSION":
                    EXRDecoder2.lines = 32;
                    EXRDecoder2.uncompress = uncompressDWA;
                    break;
                case "DWAB_COMPRESSION":
                    EXRDecoder2.lines = 256;
                    EXRDecoder2.uncompress = uncompressDWA;
                    break;
                default:
                    throw "EXRLoader.parse: " + EXRHeader2.compression + " is unsupported";
            }
            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;
            if (EXRDecoder2.type == 1) {
                switch(outputType){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FloatType"]:
                        EXRDecoder2.getter = parseFloat16;
                        EXRDecoder2.inputSize = INT16_SIZE;
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                        EXRDecoder2.getter = parseUint16;
                        EXRDecoder2.inputSize = INT16_SIZE;
                        break;
                }
            } else if (EXRDecoder2.type == 2) {
                switch(outputType){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FloatType"]:
                        EXRDecoder2.getter = parseFloat32;
                        EXRDecoder2.inputSize = FLOAT32_SIZE;
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                        EXRDecoder2.getter = decodeFloat32;
                        EXRDecoder2.inputSize = FLOAT32_SIZE;
                }
            } else {
                throw "EXRLoader.parse: unsupported pixelType " + EXRDecoder2.type + " for " + EXRHeader2.compression + ".";
            }
            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;
            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);
            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;
            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;
            switch(outputType){
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FloatType"]:
                    EXRDecoder2.byteArray = new Float32Array(size);
                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);
                    break;
                case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HalfFloatType"]:
                    EXRDecoder2.byteArray = new Uint16Array(size);
                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);
                    break;
                default:
                    console.error("THREE.EXRLoader: unsupported type: ", outputType);
                    break;
            }
            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;
            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RGBAFormat"];
            else EXRDecoder2.format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RedFormat"];
            if (hasColorSpace) EXRDecoder2.colorSpace = "srgb-linear";
            else EXRDecoder2.encoding = 3e3;
            return EXRDecoder2;
        }
        const bufferDataView = new DataView(buffer);
        const uInt8Array = new Uint8Array(buffer);
        const offset = {
            value: 0
        };
        const EXRHeader = parseHeader(bufferDataView, buffer, offset);
        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);
        const tmpOffset = {
            value: 0
        };
        const channelOffsets = {
            R: 0,
            G: 1,
            B: 2,
            A: 3,
            Y: 0
        };
        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){
            const line = parseUint32(bufferDataView, offset);
            EXRDecoder.size = parseUint32(bufferDataView, offset);
            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;
            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;
            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);
            offset.value += EXRDecoder.size;
            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){
                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;
                if (true_y >= EXRDecoder.height) break;
                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){
                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];
                    for(let x = 0; x < EXRDecoder.width; x++){
                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;
                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;
                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);
                    }
                }
            }
        }
        return {
            header: EXRHeader,
            width: EXRDecoder.width,
            height: EXRDecoder.height,
            data: EXRDecoder.byteArray,
            format: EXRDecoder.format,
            [hasColorSpace ? "colorSpace" : "encoding"]: EXRDecoder[hasColorSpace ? "colorSpace" : "encoding"],
            type: this.type
        };
    }
    setDataType(value) {
        this.type = value;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        function onLoadCallback(texture, texData) {
            if (hasColorSpace) texture.colorSpace = texData.colorSpace;
            else texture.encoding = texData.encoding;
            texture.minFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LinearFilter"];
            texture.magFilter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LinearFilter"];
            texture.generateMipmaps = false;
            texture.flipY = false;
            if (onLoad) onLoad(texture, texData);
        }
        return super.load(url, onLoadCallback, onProgress, onError);
    }
}
;
 //# sourceMappingURL=EXRLoader.js.map
}),
];

//# sourceMappingURL=node_modules_three-stdlib_002d7fb9._.js.map